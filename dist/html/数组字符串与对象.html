<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>数组和字符串</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/default.css">
	<link rel="stylesheet" href="../css/bright.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">数组字符串和对象</h1>
		</hgroup>
		<section>
			<h2>创建数组</h2>
			<p>
				<pre><code class="javascript">
// 方法一
var arr1 = [1, 2, 3];
// 方法二
var arr2 = new Array(3);
				</code></pre>
				<h3>Array(length)</h3>
				<p>
					使用方法二创建出来的数组其实不是完整的数组，正常的数组应该是：
					<pre><code class="javascript">
[1, 2, 3]
// ->
{
	0: 1,
	1, 2,
	3, 3,
	length: 3,
	__proto__: {}
}
					</code></pre>
					而方法二创建出来的数组为：
					<pre><code class="javascript">
new Array(3);
// ->
{
	length: 3,
	__proto__: {}
}
					</code></pre>
					该方法类似于直接对数组 length 进行修改。
					<pre><code class="javascript">
var arr = [1];
arr.length = 3;
// ->
{
	0: 1,
	length: 3,
	__proto__: {}
}
					</code></pre>
				</p>
				<h3>问题</h3>
				<p>
					使用方法二创建的数组，当需要使用到里面的元素时，由于并不存在这些元素，可能因此而出现问题：
					<pre><code class="javascript">
var arr = new Array(100);
var newArr = arr.map(function () { return 0 });
// ->
{
	length: 100,
	__proto__: {}
}
					</code></pre>
					上述代码本意是想生成一个长度为 100 ，填充 0 的数组，但执行 map 函数的过程中，由于并不存在实际的数组元素，因此最终返回的数组也不存在元素。
				</p>
				<h3>解决方案</h3>
				<p>
					<ul>
						<li>使用 ES6 对象展开符</li>
						<pre><code class="javascript">
var arr = [... new Array(5)];
// ->
{
	0: undefined,
	1: undeinfed,
	2: undefined,
	3: undefined,
	4: undefined,
	length: 5,
	__proto__: {}
}
						</code></pre>
						<li>使用循环</li>
						<pre><code class="javascript">
var arr = [];
for (var i = 0; i < 5; i++) {
	arr.push(undefined);
}
						</code></pre>
					</ul>
				</p>
			</p>
		</section>
		<section>
			<h2>数组方法</h2>
			<p>
				<h3>数组连接：concat / join</h3>
				<ul>
					<li>concat 不改变原来数组，而是返回一个新数组</li>
					<li>join 不改变原来数组，而是返回一个字符串</li>
				</ul>
				<pre><code class="javascript">
// concat 连接所有数组，返回一个新数组
新数组 = 数组1.concat(数组2, 数组3, ...);

var arr = [1, 2].concat([3, 4], [5, 6]);// => [1, 2, 3, 4, 5, 6]

// join 连接数组所有元素，返回一个字符串
字符串 = 数组.join(分隔符);

var string = [1, 2, 3, 4, 5].join(' '); // => '1 2 3 4 5'
				</code></pre>
				<h3>元素操作：push / unshift / pop / shift / splice / [index]</h3>
				push、unshift、pop、shift、splice 都会改变原来的数组。
				<pre><code class="javascript">
// push 在数组尾部推入元素，返回新数组长度
// unshift 在数组头部推入元素，返回新数组长度
数组.push(元素1, 元素2, ...);
数组.unshift(元素1, 元素2, ...);

var arr = [1, 2, 3];
arr.push(4, 5); // => 5
arr; // => [1, 2, 3, 4, 5]
arr.unshift(-1, 0); // => 7
arr; // => [-1, 0, 1, 2, 3, 4, 5]

// pop 在数组尾部弹出一个元素，返回弹出的元素值
// shift 在数组头部弹出一个元素，返回弹出的元素值
数组.pop();
数组.shift();

var arr = [1, 2, 3, 4, 5];
arr.pop(); // => 5
arr; // => [1, 2, 3, 4]
arr.shift(); // => 1
arr; // => [2, 3, 4]

// splice 在数组 index 位置开始删除 length 个元素和添加元素，返回被删除的元素组成的数组
数组.splice(index, length, 元素1, 元素2, ...)

var arr = ['a', 'b', 'c', 'd', 'e'];
arr.splice(2, 2, 'x', 'y', 'z'); // => ['c', 'd']
arr; // => ['a', 'b', 'x', 'y', 'z', 'e']

// 使用 [index] 的方法来添加元素
数组[index] = 元素

var arr = [];
arr[5] = 5; // => [undefined, undefined, undefined, undefined, 5]
				</code></pre>
				<h3>数组遍历：forEach / filter / map / findIndex / some / every</h3>
				六者都是对数组的遍历，传入一个函数，函数的参数完全一样
				<ul>
					<li>element：元素值，必须</li>
					<li>index：元素索引，可选</li>
					<li>array：原数组，可选</li>
				</ul>
				六者都不会改变原来数组，forEach 返回 undefined ，filter 和 map 返回新数组，findIndex 返回第一个执行函数返回 true 的 index 值，some 和 every 返回 boolean。
				<pre><code class="javascript">
// forEach 遍历所有元素，执行函数
数组.forEach(function(element, index, array){ ... });

[1, 2, 3, 4, 5].forEach(function(element, index, array){
	console.log(element);
}); // => 返回 undefined，打印 1 2 3 4 5


// filter 遍历所有元素，执行判断函数，过滤部分元素，返回新数组
// 返回值：true => 保留元素
// 返回值：false => 过滤元素
新数组 = 原数组.filter(function(element, index, array){ return ... });
arr = [1, 2, 3, 4, 5].filter(function(element){
	return element > 2;
}); // => [3, 4, 5]

// map 遍历所有元素，执行函数，对元素进行重映射，返回新数组
// 返回值 => 元素的新值
新数组 = 原数组.map(function(element, index, array){ return ... });

arr = [1, 2, 3, 4, 5].map(function(element, index, array){
	return element * element;
}); // => [1, 4, 9, 16, 25]

// findIndex 遍历所有元素并调用函数，当函数返回 true 时返回该元素的 index
数组.findIndex(function(element, index, array){ return ... });

index = [1, 2, 3, 4, 5].findIndex(function(element, index, array) {
	return element >= 3;
}); // => 2

// some 遍历所有元素并将所有返回结果进行或运算，最后将这个或运算的结果返回
bool = [1, 2, 3, 4].some(function(element, index, array) { return element > 3 }); // => true
// 其等价于
var flag = false, arr = [1, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
	flag = flag || arr[i] > 3;
}
return flag;

// every 遍历所有元素并将所有返回结果进行与运算，最后将这个与运算的结果返回
bool = [1, 2, 3, 4].every(function(element, index, array) { return element > 3 }); // => false
// 其等价于
var flag = true, arr = [1, 2, 3, 4];
for (var i = 0; i < arr.length; i++) {
	flag = flag && arr[i] > 3;
}
return flag;
				</code></pre>
				<h3>数组计算：reduce</h3>
				<p>
					reduce 类似于遍历，但会将遍历后的计算结果返回，传入两个参数。
					<ul>
						<li>计算函数，必须，函数的形参为：</li>
						<ul>
							<li>sum：当前计算累计结果</li>
							<li>element：当前元素</li>
							<li>index：当前元素的索引</li>
							<li>array：整个数组</li>
						</ul>
						<li>初始值，可选</li>
					</ul>
					<pre><code class="javascript">
var arr = [1, 2, 3, 4, 5];
var result = arr.reduce(function(sum, element, index, array) {
	return sum + element;
}, 0);
console.log(result); // => 15
					</code></pre>
					其上的运算过程为：
					<ol>
						<li>初始值 0，作为当前的 sum</li>
						<li>遍历数组第一个元素，返回 sum + arr[0]，所以 sum = 0 + 1</li>
						<li>遍历数组第二个元素，返回 sum + arr[1]，所以 sum = 1 + 2</li>
						<li>...</li>
						<li>遍历数组第五个元素，返回 sun + arr[4]，所以 sum = 10 + 5</li>
						<li>返回 sum 给 result</li>
					</ol>
				</p>
				<h3>数组排序：sort / reverse</h3>
				sort 和 reverse 都会影响原来数组。
				<pre><code class="javascript">
// sort 执行比较函数，传入前一个元素值和后一个元素值
// 返回值：< 0 => 交换元素
// 返回值：>= 0 => 不交换元素
var arr = [4, 1, 2, 3, 5];
arr.sort(function(a, b) {
	return a - b;
}); // => [1, 2, 3, 4, 5]
arr; // => [1, 2, 3, 4, 5]

// reverse 翻转数组
var arr = [1, 2, 3, 4, 5];
arr.reverse(); // => [5, 4, 3, 2, 1]
arr; // => [5, 4, 3, 2, 1]
				</code></pre>
			</p>
		</section>
		<section>
			<h2>创建字符串</h2>
			<p>
				<pre><code class="javascript">
// 方法一
var str1 = new String('hello world');
// 方法二
var str2 = 'hello world';
				</code></pre>
			</p>
		</section>
		<section>
			<h2>字符串方法</h2>
			<p>
				<h3>连接与分割：concat / split</h3>
				split 支持正则。
				<pre><code class="javascript">
// concat 多个字符串连接（其实就相当于 + 运算符）
新字符串 = 字符串1.concat(字符串2, 字符串3, ...)

'a'.concat('b', 'c'); // => 'abc'

// split 切割字符串为数组，传入字符串或正则表达式
'a.b.c.d.e.f'.split('.'); // => ['a', 'b', 'c', 'd', 'e', 'f']
'a.b.c.d.e.f'.split(/\./); // => ['a', 'b', 'c', 'd', 'e', 'f']
				</code></pre>
				<h3>查找：[index] / charAt / charCodeAt / match / indexOf / lastIndexOf / search</h3>
				<ul>
					<li>[index] / charAt(index) / charCodeAt(index)：查找索引 index 的字符 / Unicode 编码</li>
					<li>match(reg)：查找符合正则表达式的字符串（无 g）或数组（有 g）</li>
					<li>indexOf / lastIndexOf(string) ：从头 / 尾查找第一次出现 string 的 index</li>
					<li>search(string|reg)：查找符合表达式或 string 的 index</li>
				</ul>
				<pre><code class="javascript">
// 查找字符
// 查找不到时候返回 undefined
var string = 'abcdef';
string[0]; // => 'a'
string.charAt(0); // => 'a'
string.charCodeAt(0); // => 97
string.match(/a/); // => 'a'
string.match(/a/g); // => [a, a]
string[999]; // => undefined

// 查找 index
// 查找不到时返回 -1
var string = 'abccba';
string.indexOf('a'); // => 0
string.lastIndexOf('a'); // => 5
string.search('a'); // => 0
string.search(/^a\w+$/); // => 0
string.indexOf('d'); // => -1
				</code></pre>
				<h3>取子串：substr / substring / slice</h3>
				<ul>
					<li>substr(start, length)：从 start（包括） 开始取 length 个字符</li>
					<li>substring / slice(start, end)：从 start（包括） 开始到 end（不包括） 结束</li>
				</ul>
				<pre><code class="javascript">
var string = '123456';
string.substr(1, 2); // => '23'
string.substring(1, 3); // => '23'
string.slice(1, 3); // => '23'
				</code></pre>
				<h3>其他：trim / toLowerCase / toUpperCase / replace</h3>
				<ul>
					<li>trim：裁切两边空白字符</li>
					<li>toLowerCase：全部小写</li>
					<li>toUpperCase：全部大写</li>
					<li>replace：根据正则替换第一个（无 g）或者替换全部（有 g）</li>
				</ul>
				<pre><code class="javascript">
' abcdef '.trim(); // => 'abcdef'
'ABCDEF'.toLowerCase(); // => 'abcdef'
'abcdef'.toUpperCase(); // => 'ABCDEF'
'abcabc'.replace(/a/, ''); // => 'bcabc'
'abcabc'.replace(/a/g, ''); // => 'bcbc'
				</code></pre>
			</p>
		</section>
		<section>
			<h2>创建对象</h2>
			<p>
				以下三种方法都是创建一个带有一个属性名 a，值为 1 ，<span class="different"> 并以 Object.prototype 为原型 </span>的对象。
				<pre><code class="javascript">
// 方法一：字面量
var obj1 = {
	a: 1
};

// 方法二：构造函数
var obj2 = new Object();
obj2.a = 1;

// 方法三
var obj3 = Object.create(Objcet.prototype, {
	a: {
		value: 1,
		enumerable: true,
		writable: true,
		configurable: true
	}
});
				</code></pre>
			</p>
		</section>
		<section>
			<h2>对象方法</h2>
			<p>
				<h3>创建属性：Object.assign / .key / [key]</h3>
				<p>
					使用 .key 和 [key] 的方法，当对象没有该属性时创建一个。而使用 Object.assign 则是将一个对象上的所有<span class="different"> 自身的可枚举的 </span>属性直接赋值到另一个对象上，如果属性名相同，则会覆盖。
					<pre><code class="javascript">
var obj = {};
obj = Object.assign({a: 1}, obj); // 方法一
obj.b = 2; // 方法二
obj['c'] = 3; // 方法三
					</code></pre>
				</p>
				<h3>配置属性：Object.defineProperty / Object.defineProperties</h3>
				<p>
					两者都是用于配置属性，前者用于配置一个属性，后者用于一次性配置多个属性，当属性名不存在时则表示为对象创建一个属性，存在时则表示修改对象属性的描述符。
					<ul>
						<li>Object.defineProperty(对象, 属性名, 配置)</li>
						<li>Object.defineProperties(对象, {属性名: 配置})</li>
					</ul>
					<pre><code class="javascript">
var obj = {};
Object.defineProperty(obj, 'a', {
	value: '我是 a',
	configurable: true,
	writable: true,
	enumerable: true
});
Object.defineProperties(obj, {
	b: {
		get: function () {
			return '我是 b';
		},
		set: function (val) {
			console.log('你把 b 设置为了' + val);
		},
		configurable: true,
		enumerable: true
	}
});
					</code></pre>
				</p>
				<h3>获得属性配置</h3>
				<p>
					<h4>对象属性描述符</h4>
					对象属性有以下描述符：
					<table>
						<tr>
							<th>描述符</th>
							<th>解释</th>
							<th>使用 assign 或 .key 或 [key] 时的默认值</th>
							<th>使用字面量时的默认值</th>
							<th>使用 defineProperty 时的默认值</th>
						</tr>
						<tr>
							<td>value</td>
							<td>属性值 / 键值</td>
							<td>赋值的值</td>
							<td>字面量的值</td>
							<td>赋值的值，若 value 则为 undefined</td>
						</tr>
						<tr>
							<td>enumerable</td>
							<td>是否可被枚举 / 遍历</td>
							<td>true</td>
							<td>true</td>
							<td>false</td>
						</tr>
						<tr>
							<td>writable</td>
							<td>属性值是否可写 / 修改</td>
							<td>true</td>
							<td>true</td>
							<td>false</td>
						</tr>
						<tr>
							<td>configurable</td>
							<td>是否可配置，即修改描述符</td>
							<td>true</td>
							<td>true</td>
							<td>false</td>
						</tr>
						<tr>
							<td>get</td>
							<td>getter 函数，该函数的返回值便是 对象.属性名 所获得的值</td>
							<td>无</td>
							<td>无</td>
							<td>无</td>
						</tr>
						<tr>
							<td>set</td>
							<td>setter 函数，当属性的值被修改时自动被调用</td>
							<td>无</td>
							<td>无</td>
							<td>无</td>
						</tr>
					</table>
					<h4>获得描述符：Object.getOwnPropertyDescriptor</h4>
					<pre><code class="javascript">
var obj = {};
Object.defineProperty(obj, 'a', {
	value: '我是 a'
});
Object.getOwnPropertyDescriptor(obj, 'a'); // => {value: "我是 a", writable: false, enumerable: false, configurable: false}
					</code></pre>
				</p>
				<h3>遍历：for...in / Object.keys / Object.values / Object.entries</h3>
				<p>
					<ul>
						<li>for...in / Object.keys 用于取出对象的所有键名</li>
						<li>Object.values 用于取出对象的所有键值</li>
						<li>Object.entries 用于取出对象键值对</li>
					</ul>
					<pre><code class="javascript">
var obj = {
	'a': '我是 a',
	'3': '我是 3',
	1: '我是 1'
};
for (var key in obj) console.log(key); // => 1 3 a
Object.keys(obj); // => ['1', '3', 'a']
Object.values(obj); // => ['我是 1', '我是 3', '我是 a']
Object.entries(obj); // => [['1', '我是 1'], ['3', '我是 3'], ['a', '我是 a']]
					</code></pre>
					遍历时需要留意几个问题：遍历顺序、是否可枚举、是否为自身属性。
					<h4>顺序</h4>
					遍历顺序问题，四种方法取出的值的顺序遵循以下规则：
					<ul>
						<li>键名为数字（指 '1' 或 1 这种）被遍历的优先级高于非数字的字符串</li>
						<li>对于键名为数字的属性，会对其升序排序后遍历</li>
						<li>对于键名为非数字的属性，不会进行排序，会按照对象本身的顺序进行遍历</li>
					</ul>
					<h4>枚举</h4>
					四种方法都是只遍历出所有可枚举（enumerable: true）的属性。
					<h4>自身属性</h4>
					for...in 会枚举出非自身属性（即原型链上的继承下来的属性），其他三种方法只会枚举自身属性。
				</p>
				<h3>保护：Object.freeze / Object.seal</h3>
				<p>
					<table>
						<tr>
							<th>方法</th>
							<th>解释</th>
							<th>非严格模式</th>
							<th>严格模式</th>
						</tr>
						<tr>
							<td>Object.freeze</td>
							<td>冻结一个对象，使其无法被修改属性、删除属性、添加新属性</td>
							<td>无事发生</td>
							<td>报错</td>
						</tr>
						<tr>
							<td>Object.seal</td>
							<td>封闭一个对象，使其无法被删除属性、添加新属性</td>
							<td>无事发生</td>
							<td>报错</td>
						</tr>
					</table>
					<pre><code class="javascript">
var obj1 = {};
Object.freeze(obj1);
obj1.a = 1;
console.log(obj1.a); // => undefined

var obj2 = {};
Object.seal(obj2);
obj2.a = 1;
console.log(obj2.a); // => undefined
					</code></pre>
				</p>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p>
				<div>[1] 菜鸟笔记 String对象 <a href="http://www.runoob.com/jsref/jsref-obj-string.html">http://www.runoob.com/jsref/jsref-obj-string.html</a></div>
				<div>[2] MDN Object.defineProperty <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></div>
			</p>
		</section>
	</article>
</body>
</html>