<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>字符编码</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/agate.css">
	<link rel="stylesheet" href="../css/dark.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">字符编码</h1>
		</hgroup>
		<section>
			<h2>定义</h2>
			<p>
				对于计算机来说，它只认识<span class="definition"> 0 </span>和<span class="definition"> 1 </span>这两个数字，通常用低电平表示<span class="definition"> 0 </span>，用高电平表示<span class="definition"> 1 </span>。因此，在计算机中的所有数据实际上都是一堆<span class="definition"> 0 </span>和<span class="definition"> 1 </span>组成的数字。
				<figure style="text-align: center;">
					<img style="max-width: 100%;" src="../images/charset_0101.jpg" alt="加载失败">
				</figure>
				但对于人类来说，<span class="definition"> 0 </span>和<span class="definition"> 1 </span>不能表示所有信息，而是通过各种语言（中文、英文等）来进行表达与交流。此时就需要将计算机里的这些数字转化为相应的语言，也就是进行映射关系（字符编码）。以<span class="definition"> ASCII </span>为例，计算机里的<span class="definition"> 01000001 </span>（计算机看得懂）代表了英文字母<span class="definition"> A </span>（人类看得懂）。用专业一些的话表达：
				<ul>
					<li>将<span class="definition"> A </span>转化为<span class="definition"> 01000001 </span>的过程成为编码（encode）</li>
					<li>将<span class="definition"> 01000001 </span>转化为<span class="definition"> A </span>的过程成为解码（decode）</li>
				</ul>
				常用的字符编码集（0/1语言与人类语言的映射表）有以下：
				<ul>
					<li>ASCII</li>
					<li>EASCII</li>
					<li>GB系列</li>
					<li>UCS</li>
					<li>Unicode</li>
				</ul>
			</p>
		</section>
		<section>
			<h2>ASCII</h2>
			<p>
				ASCII （American Standard Code for Information Interchange，美国信息交换标准代码）是二十世纪六十年代提出的字符编码集，用 1 个字符的大小（8 bit，00000000 - 11111111）集合了26个基本拉丁字母、阿拉伯数目字和英式标点符号<sup>[1]</sup>，虽然有 8 bit 的大小，但实际上第一位（最高位）固定为<span class="definition"> 0 </span>，也就是只表示了 128（2<sup>7</sup> = 128）个字符。
				<figure>
					<img style="width: 100%;" src="../images/ascii.jpg" alt="加载失败">
					<figcaption class="description"> ASCII 表<sup>[2]</sup></figcaption>
				</figure>
			</p>
		</section>
		<section>
			<h2>EASCII</h2>
			<p>
				ASCII 传入欧洲后，由于 ASCII 没有欧洲国家的某些字符，于是出现了 EASCII（Extended ASCII，延伸美国标准信息交换码），它将 ASCII 里的第一位利用起来，用来包括表格符号、计算符号、希腊字母和特殊的拉丁符号<sup>[3]</sup>。
				<figure>
					<img style="width: 100%;" src="../images/iso_8859_1.png" alt="加载失败">
					<figcaption class="description"> iso 8859-1<sup>[4]</sup> </figcaption>
				</figure>
，			</p>
		</section>
		<section>
			<h2>GB系列</h2>
			<p>
				EASCII 已经把剩下的 128 个位置使用完，常用汉字也有 6000 多个需要表示，一个字节（8 bit，2<sup>8</sup> = 128）无法表示全部的汉字，于是出现用两个字节（8 bit + 8 bit，2<sup>8</sup> * 2<sup>8</sup> = 65536）来表示一个汉字的方法，第一个字节称为高字节，第二个字节成为低字节。
				常见的有：
				<ul>
					<li>GB2312-80（信息交换用汉字编码字符集基本集）：A1A1~FEFE</li>
					<li>GB2312：高字节A1~F7，低字节A1~FE，高频率汉字</li>
					<li>GB12345-90（信息交换用汉字编码字符集第一辅助集）：A1A1~FEFE，常用简体和部分繁体字</li>
					<li>GBK（汉字内码扩展规范1.0版）：高字节81~FE，低字节40~FE，简繁日韩</li>
					<li>BIG5：高字节A1~F9，低字节40~7E + A1~FE，繁体字</li>
					<li>GB18030（信息技术信息交换用汉字编码字符集基本集的扩充）：变字节，1 字节 00~7F，2 字节高字节81~FE低字节40~7E + 80~FE，4 字节一三字节81~FE二四字节30~39，世界上大多数可书写的字符</li>
				</ul>
			</p>
		</section>
		<section>
			<h2>UCS</h2>
			<p>
				美国使用 ASCII ，欧洲使用 EASCII ，中国使用 GB系列，一些国家也制定了自己国家的字符编码，为了解决不同国家的编码问题，ISO（国际标准化组织）推出了包括全球文字的字符编码集 UCS （Universal Coded Character Set）。 UCS 只兼容了 ASCII 的 128 个字符，不兼容其他字符编码集。目前存在两种版本的 UCS 编码集。
				<ul>
					<li>UCS-2：每个字符使用两个字节（16 bit），可以表示 65536 个字符，包括了全球大部分的字符</li>
					<li>UCS-4：每个字符使用四个字节（32 bit），可以表示 21 亿多个字符</li>
				</ul>
			</p>
		</section>
		<section>
			<h2>Unicode</h2>
			<p>
				由 Xerox、Apple 等软件制造商于 1988 年组成 Unicode 联盟（The Unicode Consortium），也推出了自己的字符编码标准，称为 Unicode 。1991年前后，两个项目的参与者( Unicode 联盟和 ISO 组织）都认识到，世界不需要两个不兼容的字符集（UCS 和 Unicode）。于是，它们开始合并双方的工作成果，并为创立一个单一编码表而协同工作<sup>[6]</sup>。之后的时间就是不断给 Unicode 编码表添加新的字符进去。
				<figure>
					<img src="../images/unicode.png" alt="加载失败">
					<figcaption class="description"><a href="https://unicode-table.com/en/">部分 Unicode 编码</a></figcaption>
				</figure>
				unicode 实际上做的是给每个字符一个唯一的编号，比如空字符（null）为 0x0，数字 0 为 0x30，字母 A 为 0x41。
				<h3>javascript 中的 unicode</h3>
				<p>
					javascript 支持 unicode 编码，可以直接使用 '\uxxxx' 或 '\uxxxx\uxxxx' 来查 unicode 表中相应的字符，返回的是对于字符的字符串。（需要注意，xxxx 是 16 进制的数，而不是 10 进制的数）
					<pre><code class="javascript">
'\u0000' === '\0' // => true
'\u0030' === '0' // => true
'\u0041' === 'A' // => true
					</code></pre>
				</p>
				<h3>实现</h3>
				<p>
					Unicode 只是将人类语言与0/1语言进行映射，并没有谈到具体实现，如果按照 UCS 一样粗暴地规定每个字符都是二或者四个字节，势必会存在大量的浪费（网络传输过程中大多数都是字母和数字，对于这些字符使用 ASCII 编码只占一个字节）。对 Unicode 有以下常见实现：
					<ul>
						<li>UTF-8</li>
						<li>UTF-16</li>
						<li>UTF-32</li>
					</ul>
					<p>
						<h4>UTF-8</h4>
						UTF-8 （Unicode Transformation Format - 8）是使用最广的字符编码，使用变长的编码方式（1 个字符占 1/2/3/4 个字节）（哈夫曼编码思想）。
						<ul>
							<li>单字节的字符：0xxxxxxx（完全兼容 ASCII）</li>
							<li>双字节的字符：110xxxxx 10xxxxxx</li>
							<li>三字节的字符：1110xxxx 10xxxxxx 10xxxxxx</li>
							<li>四字节的字符：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</li>
						</ul>
						Unicode 转 UTF-8 的方法是在 Unicode 表里找到对应字符的 0/1 编码，填充到上面的 x 里面，多余的 x 用 0 进行补全。例如中文的<span class="definition"> 中 </span>在 Unicode 中是<span class="definition"> 4e2d / 100111000101101</span>，共有 15 bit，也就是至少占用三字节。Unicode 转化为 UTF-8：
						<pre><code class="java">
100111000101101 => 100 111000 101101		（Unicode）
			+
	1110xxxx 10xxxxxx 10xxxxxx
		       ||
	1110x100 10111000 10101101
		       ||
	11100100 10111000 10101101	（UTF-8）
						</code></pre>
						由此也可以得出，使用 UTF-8 编码可以编码 0 - 111111111111111111111 区间的 unicode 字符，也就是 0 - 1FFFF 位置的字符。
					</p>
					<p>
						<h4>UTF-16</h4>
						UTF-16 统一使用两个字节来表示字符，不兼容 ASCII ，对于英文和数字也得占用两个字节。比起 UTF-8 更占用资源，但可以表示 Unicode 中码位大于 1FFFFF的字符（转化为二进制是 21 个 1，UTF-8 只能表示 Unicode 中码位为 0 ~ 1FFFFF 的字符） 。在 Unicode 中不同码位的字符和 UTF-16 之间有不同转化方式：
						<ul>
							<li>U+0000~U+D7FF 和 U+E000~U+FFFF：Unicode 等价于 UTF-16</li>
							<li>U+10000~U+10FFFF：码位 - 0x10000 = 20 个 0/1，前 10 个 0/1 | 0xD800 = UTF-16 的高字节，后 10 个 0/1 | 0xDC00 =UTF-16 的低字节</li>
							<li>U+D800~U+DFFF：在 Unicode 中不对应于任何字符</li>
						</ul>
						值得注意的是，UTF-16 存在 大尾序和小尾序的概念。UTF-16 的大尾序和小尾序存储形式都在使用。两个字节的 UTF-16 字符用大尾序方式先读高位再度低位，小尾序先读低位再读高为。例如读取 D0A8801C
						<pre><code class="java">
D0 A8 80 1C // 大尾序
A8 D0 1C 80 // 小尾序
						</code></pre>
						 一般来说，以 Macintosh 制作或存储的文字使用大尾序格式，以 Microsoft 或 Linux 制作或存储的文字使用小尾序格式<sup>[10]</sup>。
					</p>
				</p>
			</p>
		</section>
		<section>
			<h2>编码与解码</h2>
			<p>
				<h3>Javascript</h3>
				<p>
					在 Javascript 中，与编码相关的（全局）函数有三个：
					<ul>
						<li>escape 和 unescape</li>
						<li>encodeURI 和 decodeURI</li>
						<li>encodeURIComponent 和 decodeURIcomponent</li>
					</ul>
					<h4>escape</h4>
					escape(string) 将 string 转义为 unicode 编码，即 %xx 或 %uxxxx，除了以下字符不进行编码：
					<ul>
						<li>数字</li>
						<li>字母</li>
						<li>* @ - _ + . /</li>
					</ul>
					<h4>encodeURI</h4>
					encodeURI(string) 将 string 转义为 utf-8 编码，即 %xx，除了以下字符不进行编码：
					<ul>
						<li>数字</li>
						<li>字母</li>
						<li> - _ . ! ~ * ' ( ) ; / ? : @ & = + $ , #</li>
					</ul>
					<h4>encodeURIComponent</h4>
					encodeURIComponent(string) 将 string 转义为 utf-8 编码，即 %xx，除了以下字符不进行编码：
					<ul>
						<li>数字</li>
						<li>字母</li>
						<li> - _ . ! ~ * ' ( )</li>
					</ul>
					<pre><code class="javascript">
var string = 'http://demo.com/index.html?username=用户&password=123456';
escape(string); // => http%3A//demo.com/index.html%3Fusername%3D%u7528%u6237%26password%3D123456
encodeURI(string); // => http://demo.com/index.html?username=%E7%94%A8%E6%88%B7&password=123456
encodeURIComponent(string); // => http%3A%2F%2Fdemo.com%2Findex.html%3Fusername%3D%E7%94%A8%E6%88%B7%26password%3D123456
					</code></pre>
				</p>
				<h3>PHP</h3>
				<p>
					<ul>
						<li>rawurlencode 和 rawurldecode</li>
						<li>urlencode 和 urldecode</li>
					</ul>
					<h4>rawurlencode</h4>
					rawurlencode($string) 按照 RFC 3986 对 URL 进行编码，将 $string 转义为 utf-8 编码，即 %xx，除了以下字符不进行编码：
					<ul>
						<li>数字</li>
						<li>字母</li>
						<li>- _ .</li>
					</ul>
					<h4>urlencode</h4>
					urlencode($string) 将 $string 转义为 utf-8 编码，即 %xx，除了以下字符不进行编码：
					<ul>
						<li>数字</li>
						<li>字母</li>
						<li>- _ .</li>
					</ul>
					<div class="tip">
						注意： urlencode 会将<span class="definition"> 空格 </span>编码为<span class="definition"> + </span>，而不是<span class="definition"> %20 </span>。
					</div>
				</p>
				<h3>Java - Servlet</h3>
				<p>
					<h4>获得客户端请求头 Content-Type 的 charset</h4>
					通过 HttpServletRequest.getCharacterEncoding 来获得客户端发送的请求头 Content-Type 设置的字符编码，如果没有这个请求头，则得到 null 。
					<pre><code class="java">
request.getCharacterEncoding();
					</code></pre>
					<figure>
						<img src="../images/charset_servlet_getcharacterencode.jpg">
					</figure>
					<h4>设置客户端数据的解码方式</h4>
					Servlet 容器会有一个默认的对客户端数据的解码方式，比如 ISO-8859-1 ，服务器收到客户端的数据后就会对数据进行解码，相当于进行了以下操作：
					<pre><code class="java">
java.net.URLDecoder.decode(客户端的数据, "ISO-8859-1");
					</code></pre>
					实际上，客户端发送的数据的编码方式不一定是 ISO-8859-1 编码，比如可能使用 utf-8 进行编码，如果是这样以上结果会得到乱码。所以通过 HttpServletRequest.setCharacterEncoding 来手动设置解码方式。但这个方法只能影响到请求体，所以对 GET 请求无效（GET 请求没有请求体）。
					<pre><code class="java">
request.setCharacterEncoding("utf-8");
					</code></pre>
					<h4>进行数据编码方式转换</h4>
					如果是 GET 请求获得的数据，或在返回的时候想要将数据进行编码格式的变化，假如已经知道原来的编码方式，想要转化为另一种编码方式，就要进行以下操作：
					<pre><code class="java">
String preCharset = "ISO-8859-1"; // 原先的字符编码方式
String nextCharset = "utf-8"; // 即将进行的编码方式
String data = "我是数据"; // 要被转换的数据
data = new String(data.getBytes(preCharset), nextCharset);
					</code></pre>
					<h4>设置响应头 Content-Type</h4>
					既可以使用 HttpServletResponse.setCharacterEncoding 来设置字符编码。
					<pre><code class="java">
response.setCharacterEncoding("utf-8");
					</code></pre>
					也可以使用 HttpServletResponse.setContentType 设置 Content-Type 来让客户端知道数据类型和解码方式。
					<pre><code class="java">
response.setContentType("text/html; charset=utf-8");
					</code></pre>
					以下两种方式是等价的：
					<pre><code class="java">
// 方式一
response.setCharacterEncoding("utf-8");
response.setContentType("text/html");

// 方式二
response.setContentType("text/html; charset=utf-8");
					</code></pre>
				</p>
			</p>
		</section>
		<section>
			<h2>判断是哪种编码</h2>
			<p>
				<h3>txt</h3>
				<p>
					在 Window 下，判断 txt 文件的编码格式：使用记事本打开后另存为。
					<figure>
						<img src="../images/code_which.jpg" alt="">
					</figure>
				</p>
				<h3>html</h3>
				<p>
					html 的 meta 标签可以告诉浏览器该 html 文档解码时使用哪种解码方式：
					<pre><code class="html">
&lt;meta charset="utf-8">
					</code></pre>
				</p>
				<h3>Content-Type</h3>
				<p>
					Content-Type 是 HTTP 协议的一个通用报文头，指定数据的格式和<span class="different">解码</span>方式。
					<ul>
						<li>如果是客户端发送请求的请求头，则表示客户端发送的数据服务器该用什么方式解码</li>
						<li>如果是服务器端响应的响应头，则表示客户端收到返回数据后该用什么方式解码</li>
					</ul>
					<pre><code class="http">
Content-Type: text/html; charset=utf-8
					</code></pre>
				</p>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p>
				<div>[1] 维基百科 ASCII <a href="https://zh.wikipedia.org/wiki/ASCII">https://zh.wikipedia.org/wiki/ASCII</a></div>
				<div>[2] 百度百科 ASCII <a href="https://baike.baidu.com/item/ASCII">https://baike.baidu.com/item/ASCII</a></div>
				<div>[3] 维基百科 EASCII <a href="https://zh.wikipedia.org/wiki/EASCII">https://zh.wikipedia.org/wiki/EASCII</a></div>
				<div>[4] Nick Gammon Character sets, encodings, and Unicode <a href="http://www.gammon.com.au/unicode/">http://www.gammon.com.au/unicode/</a></div>
				<div>[5] 郭承来 字符编码历史（字符编码详解）<a href="http://guochenglai.com/2016/06/03/coding-history/">http://guochenglai.com/2016/06/03/coding-history/</a></div>
				<div>[6] 维基百科 通用字符集 <a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86">https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86</a></div>
				<div>[7] 享受编程_ ASCII、GBK、unicode、utf-8、iso-8859-1等编码的发展史和相互关系 <a href="http://blog.csdn.net/u013476542/article/details/51691380">http://blog.csdn.net/u013476542/article/details/51691380</a></div>
				<div>[8] Literal strings Unicode <a href="https://learn.rmotr.com/python/understanding-unicode-in-python/strings-and-unicode/unicode-in-python">https://learn.rmotr.com/python/understanding-unicode-in-python/strings-and-unicode/unicode-in-python</a></div>
				<div>[9] 阮一峰 字符编码笔记：ASCII，Unicode 和 UTF-8 <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></div>
				<div>[10] 维基百科 UTF-16 <a href="https://zh.wikipedia.org/wiki/UTF-16">https://zh.wikipedia.org/wiki/UTF-16</a></div>
				<div>[11] PHP手册 rawurlencode <a href="http://php.net/manual/zh/function.rawurlencode.php">http://php.net/manual/zh/function.rawurlencode.php</a></div>
				<div>[12] Servlet 中文处理 <a href="https://openhome.cc/Gossip/Encoding/Servlet.html">https://openhome.cc/Gossip/Encoding/Servlet.html</a></div>
			</p>
		</section>
	</article>
</body>
</html>