<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>软件设计师</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/agate.css">
	<link rel="stylesheet" href="../css/dark.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">软件设计师</h1>
		</hgroup>
		<section>
			<h2>程序语言</h2>
			<p>
				<h3>文法</h3>
				<p>
					文法是推导规则，比如
					<pre><code class="language">
A → B|C|DEF
					</code></pre>
					那么就表示 A 可以推出 B 或 C 或 DEF ，A 称为开始符号，也称为非终结符（Vn），如果 B 推不出任何东西，则 B 称之为终结符（Vr）。进行推导本身的文法和所有被推导出来的结果称之为产生式。
					<ul>
						<li>算符文法：所有产生式的右边都不包含连续的两个非终结符</li>
						<li>终结符优先级：其实就是看终结符哪个先被推导出来，先被推导出来的优先级大于后出现的</li>
					</ul>
					文法类型：
					<ul>
						<li>左线性文法：左边只有一个符号，右边是非终结符 + 终结符</li>
						<li>右线性文法：左边只有一个符号，右边是终结符 + 非终结符</li>
						<li>3 型文法：左边只有一个符号，右边最多两个符号，如果是两个符号则必须是终结符 + 非终结符</li>
						<li>2 型文法：左边只有一个符号，右边有限个符号</li>
						<li>1 型文法：左边任意个符号，但至少要有一个终结符，右边有限个符号</li>
						<li>0 型文法：任意文法</li>
					</ul>
				</p>
				<h3>相关概念</h3>
				<p>
					假设有<span class="different"> A → BF </span>和<span class="different"> B → CDE </span>和<span class="different"> F → G </span>和<span class="different"> C → H</span>。
					构建树得到：
					<figure>
						<img src="../images/software_engineer_tree.jpg">
					</figure>
					<ul>
						<li>短语：构建一棵树后取任意一个子树，推导到最终得到的结果。比如上图就是 HDEF、HDE、H 和 G</li>
						<li>直接短语：基于短语的基础上，如果推导一次就结束了，比如 F → G 然后 G 无法再进行推导，则称为直接短语。比如上图的 H 和 G</li>
						<li>句柄：基于直接短语的基础上，如果推导处于最左边，比如 C → H，则成为句柄。比如 C</li>
						<li>最左推导：每次都优先从最左边进行推导，比如 AXXXC 里虽然 C 可以推导为 D，但结果只能是 BXXXC，C 被不可推导的 X 挡住了</li>
						<li>最右推导：每次都优先从最右边进行推导，在形式语言中，最右推导常被称为规范推导</li>
						<li>推导：可以在任意位置进行推导</li>
					</ul>
				</p>
				<h3>编译程序</h3>
				<p>
					<ol>
						<li>词法分析：将字符序列转化为 token 的过程。用户输入的只是一系列字符，词法分析则将这些字符进行切割</li>
						<li>语法分析：将 token 序列组成语法短语</li>
						<ul>
							<li>自上向下：给定文法G和源程序串r，按照正常顺序进行<span class="different">推导</span>得到r。有<span class="definition"> LL(1) </span>方法</li>
							<li>自下向上：从给定的输入串r开始，不断寻找子串与文法G中某个产生式P的候选式进行匹配，并用P的左部代替(归约)之，逐步<span class="different">归约</span>到开始符号S。有<span class="definition"> LR(1)、SLR(1)、LALR(1) </span>方法</li>
						</ul>
						<li>语义分析：对程序的语义进行解释</li>
						<li>中间代码生成</li>
						<li>代码优化</li>
						<li>目标代码生成</li>
					</ol>
				</p>
			</p>
		</section>
		<section>
			<h2>网络</h2>
			<p>
				<h3>ISO 7 层模型</h3>
				<p>
					<ol>
						<li>物理层：物理上存在的数据传输线路线，以 bit 传输：网线、集线器、中继器、HUB</li>

						<li>数据链路层：寻找物理地址，重发，流控制，以数据帧传输：网卡、二层交换机、网桥</li>
						<li>网络层：路由寻址，分组转发，以数据包传输：路由器、防火墙、多层交换机</li>
						<li>传输层：进程间的连接建立，控制数据包的发送，以数据段传输：进程、端口</li>
						<li>会话层：会话管理，访问校验</li>
						<li>表示层：加密解密，编码解码，压缩解压</li>
						<li>应用层：提供网络服务接口</li>
					</ol>
				</p>
				<h3>TCP/IP协议组</h3>
				<p>
					<ol>
						<li>物理层</li>
						<li>数据链路层</li>
						<li>网络层：有 IP、ICMP、ARP 与 RARP 等协议</li>
						<li>传输层：有 TCP、UDP 等协议</li>
						<li>应用层：有 HTTP、FTP、Telnet 等协议</li>
					</ol>
				</p>
				<h3>数据校验</h3>
				<p>
					<h4>奇偶校验</h4>
					奇偶校验就是在发送的数据后追加一位（bit）数据，若前面的数据 1 的个数为奇数则追加 1（或相反），若前面的数据 1 的个数为偶数则追加 0（或相反）。收到数据后判断最后的这一位是否符合奇偶校验。
					<h4>海明码</h4>
					海明码是在数据里面插入校验数据，插入的位置是 Math.pow(2, k) ，k 是非负整数，比如要传输数据 + 校验码长度为 16 ，也就是数据为 0000 - 1111 。
					<div><table>
						<tr>
							<th>0000</th>
							<th class="is-different">0001（Math.pow(2, 0)）</th>
							<th class="is-different">0010（Math.pow(2, 1)）</th>
							<th>0011</th>
							<th class="is-different">0100（Math.pow(2, 2)）</th>
							<th>0101</th>
							<th>0110</th>
							<th>0111</th>
							<th class="is-different">1000（Math.pow(2, 3)）</th>
							<th>1001</th>
							<th>1010</th>
							<th>1011</th>
							<th>1100</th>
							<th>1101</th>
							<th>1110</th>
							<th>1111</th>
						</tr>
						<tr>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
						</tr>
					</table></div>
					校验码的生成规则为，将所有与该校验码为 1 的那一位所在位置也为 1 的数据进行异或运算，得到的结果为 0 。比如取第一个校验码，位置是 0001，那么就取所有位置为 XXX1 的数据进行异或运算：
					<pre><code class="javascript">
000<span class="strong">1</span>的校验码 ^ 001<span class="strong">1</span>的数据 ^ 010<span class="strong">1</span>的数据 ^ 011<span class="strong">1</span>的数据 ^ 100<span class="strong">1</span>的数据 ^ 101<span class="strong">1</span>的数据 ^ 110<span class="strong">1</span>的数据 ^ 111<span class="strong">1</span>的数据
					</code></pre>
					全部异或运算得到的值必须为 0 ，数据都是已知的，所以可以求出校验码的值。
					<div class="tip">
						异或运算符合交换律。进行异或运算其实是看有多少个 1 ，1 与无限个 0 进行异或运算的结果还是 1 ，然后偶数个 1 进行异或得到 0 ，奇数个 1 进行异或得到 1 。所以进行以上异或运算必须要有偶数个 1 才能得到结果 0 。
					</div>
					收到数据 + 校验码后在进行校验，如果进行异或运算结果是 1 ，则说明数据出现了问题，无论是数据从 0 变成了 1 还是 1 变成 0 都会使得异或运算的结果出错，使用这个方法我们可以知道出错的位置在哪里，实现纠错功能。
					<h4>海明码纠原理</h4>
					一旦数据的一个位出错，将会有多个校验码验算的时候结果不为 0 。相当于一道数学题：<span class="different">如何使用 k 只老鼠检查 Math.pow(2, k) 瓶药剂中哪一瓶（也只有一瓶是）是有毒的？</span>数学模型规定毒药吃下去在一定时间后（比如一周）才会死亡，而只给你一定时间来测试（比如一周）。解决方法是将老鼠按位进行试验。
					<figure>
						<img src="../images/software_engineer_mice_1.jpg">
					</figure>
					将老鼠安排下去，谁的那一列是 1 就得喝一口对应号码的药剂，比如第 k 号老鼠就得喝 1、3、5、7 ...... Math.pow(2, k)号瓶子：
					<figure>
						<img src="../images/software_engineer_mice_2.jpg">
					</figure>
					一周后看死了哪些老鼠，将药剂号码转化成二进制，谁死了说明毒药的二进制数字对应的那一位为 1 ，比如第 k - 1、k 号老鼠死了，其他老鼠没有死，那么 00 ...... 011 号瓶子是毒药，也就是 3 号瓶子是毒药。
					<figure>
						<img src="../images/software_engineer_mice_3.jpg">
					</figure>
				</p>
				<h3>安全</h3>
				<p>
					<h4>攻击</h4>
					<ul>
						<li>主动攻击：中断、修改、伪造数据</li>
						<li>被动攻击：非法获得某些数据，但又不修改这些数据，也就是窃取 / 偷窥</li>
					</ul>
					<h4>防火墙</h4>
					<ol>
						<li>日记与事件记录：记录网络使用情况</li>
						<li>审计监控：记录访问日志</li>
						<li>IP 地址转换：NAT 技术</li>
						<li>数据包过滤</li>
						<li>防止内部信息的外泄</li>
						<li>虚拟专用网络</li>
						<li>强化网络安全策略</li>
					</ol>
				</p>
			</p>
		</section>
		<section>
			<h2>CPU</h2>
			<p>
				<h3>控制方式</h3>
				<p>
					进行 IO 操作（外设）时候，怎么让 CPU 知道 IO 操作是否完成，在 IO 时 CPU 又在做什么？
					<ul>
						<li>程序查询方式：即让 CPU 不停地询问外设是否完成，这个过程 CPU 只做询问，不做其他事情</li>
						<li>程序中断方式：CPU 和外设各自进行工作，当外设完成工作的时，给 CPU 一个中断信号，CPU 就会停下手头的工作（保存现场信息）来处理中断信息，处理完之后再恢复现场信息</li>
						<li>DMA：Direct Memory Access，直接借助硬件来完成 IO 操作，CPU 可以不用专门管理 IO 过程</li>
					</ul>
				</p>
			</p>
		</section>
		<section>
			<h2>模型</h2>
			<p>
				<h3>数据流图 / DFD</h3>
				<p>
					数据流图从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程。<sup>[1]</sup>
					<ul>
						<li>数据流：数据在系统内传播的路径，如姓名、年龄、单位、身份证号、日期、目的地等</li>
						<li>数据源或宿：代表系统之外的实体，如人、动物、系统</li>
						<li>加工：对数据进行处理的单元</li>
						<li>数据存储：表示信息的静态存储</li>
					</ul>
				</p>
				<h3>关系实体图 / E-R图</h3>
				<p>
					想想你的数据库原理怎么学的。
				</p>
			</p>
		</section>
		<section>
			<h2>操作系统</h2>
			<p>
				<h3>PCB</h3>
				<p>
					PCB：进程控制块，一种专门描述进程的数据结构，有这个进程控制块，系统才感知到进程。
					<figure>
						<img src="../images/software_engineer_pcb.jpg">
						<figcaption>https://baike.baidu.com/item/进程控制块/7205297?fr=aladdin</figcaption>
					</figure>
					PCB 放在系统的内存上，由于系统上运行着多个进程，系统需要知道哪些进程正在执行，哪些进程阻塞中，所以就需要根据 PCB 来调度进程，有三种存放方式：
					<ul>
						<li>线性表方式：不管进程的状态，直接将所有 PCB 顺序放置</li>
						<li>索引表方式：维护一个就绪索引表和一个阻塞索引表，索引是 PCB 块的首地址</li>
						<figure>
							<img src="../images/software_engineer_pcb_index.jpg">
						</figure>
						<li>链接表方式：每个 PCB 块都有一个指针，指向下一个 PCB 块的首地址，然后创建就绪指针、阻塞指针、空闲指针，分别指向一个 PCB 块的首地址。当进程状态发生改变的时候，就将这个进程的 PCB 链接到另一个链表上。</li>
						<figure>
							<img src="../images/software_engineer_pcb_link.jpg">
							<figcaption>https://blog.csdn.net/canyanruxue/article/details/78439934</figcaption>
						</figure>
					</ul>
				</p>
				<h3>磁盘</h3>
				<p>
					<h4>磁盘结构</h4>
					<figure>
						<img src="../images/software_engineer_disk.jpg">
						<figcaption>磁盘结构</figcaption>
					</figure>
					<ul>
						<li>磁盘片：上下面都可以存储数据</li>
						<li>磁道：磁盘片上的同心圆</li>
						<li>扇区：磁道切割成若干个扇区，一个扇区称之为一个盘块（数据块）</li>
					</ul>
					<h4>时间计算</h4>
					磁盘是一直在旋转的，读写的磁头则由主杆操作只能进行前后移动，所以如果要读取磁盘上某个地方的数据，需要：
					<ol>
						<li>主杆控制磁头移动到目标磁道上：设 m 类似于主杆移动速度，是一个常数，n 是磁头距离目标有多少磁道，s 主杆启动时间，这个过程需要总时间 s + m * n</li>
						<li>等待磁盘旋转到磁头的位置：由于磁盘旋转无法停止，所以磁头移动到目标磁道上的时候既有可能是刚好就可以进行读写，也可能刚好错过，因此使用 T / 2 作为计算时间，T 是磁盘旋转一周所需时间</li>
						<li>传输时间：r 为磁盘每秒转多少圈，N 为一条磁道上有多少字节，b 为要读取多少字节，因此需要时间 b / (r * N)</li>
					</ol>
					<h4>磁盘调度</h4>
					当有多个读写请求的时候，该先响应哪个请求？
					<ul>
						<li>先来先服务（FCFS）：顾名思义。但可能恰好几个请求的读写位置相差甚远，导致磁头跑来跑去</li>
						<li>最短寻道优先（SSTF）：根据现在磁头所在的位置，优先选择一条最近的。但可能让磁头一直待在某个地方，因为不断有近的请求进来，导致虽然先来但是请求位置比较远而一直得不到响应</li>
						<li>扫描算法（SCAN）：电梯算法，每次都只向一个方向移动，直到这个方向上没有请求，再调换方向</li>
						<li>循环扫描算法：从最外层有请求的磁道往最内层磁道扫描，扫完后回到最外侧有请求的磁道，重复以上</li>
						<li>NStepSCAN：先将众多请求分成若干个子队列，然后依次对每个子队列使用扫描算法</li>
						<li>FSCAN 调度算法：将众多请求分成若两个子队列，然后依次对子队列使用扫描算法</li>
					</ul>
				</p>
				<h3>磁盘分配</h3>
				<p>
					一个磁盘被分为多个同心圆的磁道，一个磁盘又被分为多个扇区 / 数据块，如果我们有一些数据，需要 k 个数据块才能存储，那么该如何分配与组织数据块？
					<ul>
						<li>连续分配方式：直接分配相邻数据块，只需要知道第一个盘块号是多少以及块数，就可以直接连续读取，但需要预先知道是否有足够多的连续数据块</li>
						<li>不连续分配：隐式链接、显式链接、索引</li>
						<ul>
							<li>隐式链接：每一个盘块保存一个指针，指向下一个盘块的盘块号，读写的时候只能从头开始</li>
							<li>显式链接：维护一张文件分配表（FAT），一个 PCB 只需要保存这个表的索引，就可以通过表来寻找所有数据块</li>
							<figure>
								<img src="../images/software_engineer_fat_table.jpg">
							</figure>
							<li>索引分配：文件分配表（FAT）提供了所有盘块的索引，然而有时候并不需要知道所有的索引。索引分配就是为每个文件分配一张索引表，每次读取某个文件只需要调出对应的表就行</li>
							<figure>
								<img src="../images/software_engineer_file_index.jpg">
							</figure>
							<ul>
								<li>一级索引分配：如上图</li>
								<li>多级索引分配：索引表保存的盘号还是一个索引表，多次索引后才是数据真正的地址</li>
							</ul>
							<li>混合索引：既可能有直接地址，也可能有一级、多级索引</li>
						</ul>
					</ul>
					<h4>两级索引计算</h4>
					假设一个盘块大小为 p ，保存一个盘块号需要占用 h 大小，那么一个盘块可以保存 p / h 个盘块号，采用两级索引，因此一个盘块可以索引到 (p / h) * (p / h) 个盘块，前面已经知道一个盘块大小为 p ，所以两级索引下一个盘块可以索引出 (p / h) * (p / h) * p 长度的文件。
				</p>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p>
				<div>[1] 数据流图 <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4136477?fromtitle=dfd&fromid=65845&fr=aladdin#1">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4136477?fromtitle=dfd&fromid=65845&fr=aladdin#1</a></div>
				<div>[2] 进程控制块 <a href="https://baike.baidu.com/item/进程控制块/7205297?fr=aladdin">https://baike.baidu.com/item/进程控制块/7205297?fr=aladdin</a></div>
				<div>[3] 进程控制块及其作用、组织方式 <a href="https://blog.csdn.net/canyanruxue/article/details/78439934">https://blog.csdn.net/canyanruxue/article/details/78439934</a></div>
				<div>[4] 汤小丹 计算机操作系统(第三版)</div>
			</p>
		</section>
	</article>
</body>
</html>