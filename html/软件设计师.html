<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>软件设计师</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/agate.css">
	<link rel="stylesheet" href="../css/dark.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">软件设计师</h1>
		</hgroup>
		<section>
			<h2>程序语言</h2>
			<p>
				<h3>文法</h3>
				<p>
					文法是推导规则，比如
					<pre><code class="language">
A → B|C|DEF
					</code></pre>
					那么就表示 A 可以推出 B 或 C 或 DEF ，A 称为开始符号，也称为非终结符（Vn），如果 B 推不出任何东西，则 B 称之为终结符（Vr）。进行推导本身的文法和所有被推导出来的结果称之为产生式。
					<ul>
						<li>算符文法：所有产生式的右边都不包含连续的两个非终结符</li>
						<li>终结符优先级：其实就是看终结符哪个先被推导出来，先被推导出来的优先级大于后出现的</li>
					</ul>
					文法类型：
					<ul>
						<li>左线性文法：左边只有一个符号，右边是非终结符 + 终结符</li>
						<li>右线性文法：左边只有一个符号，右边是终结符 + 非终结符</li>
						<li>3 型文法：左边只有一个符号，右边最多两个符号，如果是两个符号则必须是终结符 + 非终结符</li>
						<li>2 型文法：左边只有一个符号，右边有限个符号</li>
						<li>1 型文法：左边任意个符号，但至少要有一个终结符，右边有限个符号</li>
						<li>0 型文法：任意文法</li>
					</ul>
				</p>
				<h3>相关概念</h3>
				<p>
					假设有<span class="different"> A → BF </span>和<span class="different"> B → CDE </span>和<span class="different"> F → G </span>和<span class="different"> C → H</span>。
					构建树得到：
					<figure>
						<img src="../images/software_engineer_tree.jpg">
					</figure>
					<ul>
						<li>短语：构建一棵树后取任意一个子树，推导到最终得到的结果。比如上图就是 HDEF、HDE、H 和 G</li>
						<li>直接短语：基于短语的基础上，如果推导一次就结束了，比如 F → G 然后 G 无法再进行推导，则称为直接短语。比如上图的 H 和 G</li>
						<li>句柄：基于直接短语的基础上，如果推导处于最左边，比如 C → H，则成为句柄。比如 C</li>
						<li>最左推导：每次都优先从最左边进行推导，比如 AXXXC 里虽然 C 可以推导为 D，但结果只能是 BXXXC，C 被不可推导的 X 挡住了</li>
						<li>最右推导：每次都优先从最右边进行推导，在形式语言中，最右推导常被称为规范推导</li>
						<li>推导：可以在任意位置进行推导</li>
					</ul>
				</p>
				<h3>编译程序</h3>
				<p>
					<ol>
						<li>词法分析：将字符序列转化为 token 的过程。用户输入的只是一系列字符，词法分析则将这些字符进行切割</li>
						<li>语法分析：将 token 序列组成语法短语</li>
						<ul>
							<li>自上向下：给定文法G和源程序串r，按照正常顺序进行<span class="different">推导</span>得到r。有<span class="definition"> LL(1) </span>方法</li>
							<li>自下向上：从给定的输入串r开始，不断寻找子串与文法G中某个产生式P的候选式进行匹配，并用P的左部代替(归约)之，逐步<span class="different">归约</span>到开始符号S。有<span class="definition"> LR(1)、SLR(1)、LALR(1) </span>方法</li>
						</ul>
						<li>语义分析：对程序的语义进行解释</li>
						<li>中间代码生成</li>
						<li>代码优化</li>
						<li>目标代码生成</li>
					</ol>
				</p>
			</p>
		</section>
		<section>
			<h2>网络</h2>
			<p>
				<h3>ISO 7 层模型</h3>
				<p>
					<ol>
						<li>物理层：物理上存在的数据传输线路，以 bit 传输</li>
						<li>数据链路层：以数据帧传输</li>
						<li>网络层</li>
						<li>传输层</li>
						<li>会话层</li>
						<li>表示层</li>
						<li>应用层</li>
					</ol>
				</p>
				<h3>TCP/IP协议组</h3>
				<p>
					<ol>
						<li>物理层</li>
						<li>数据链路层</li>
						<li>网络层：有 IP、ICMP、ARP 与 RARP 等协议</li>
						<li>传输层：有 TCP、UDP 等协议</li>
						<li>应用层：有 HTTP、FTP、Telnet 等协议</li>
					</ol>
				</p>
				<h3>数据校验</h3>
				<p>
					<h4>奇偶校验</h4>
					奇偶校验就是在发送的数据后追加一位（bit）数据，若前面的数据 1 的个数为奇数则追加 1（或相反），若前面的数据 1 的个数为偶数则追加 0（或相反）。收到数据后判断最后的这一位是否符合奇偶校验。
					<h4>海明码</h4>
					海明码是在数据里面插入校验数据，插入的位置是 Math.pow(2, k) ，k 是非负整数，比如要传输数据加校验码长度为 16：
					<div>
					<table>
						<tr>
							<th class="is-different">0001（Math.pow(2, 0)）</th>
							<th class="is-different">0010（Math.pow(2, 1)）</th>
							<th>0011</th>
							<th class="is-different">0100（Math.pow(2, 2)）</th>
							<th>0101</th>
							<th>0110</th>
							<th>0111</th>
							<th class="is-different">1000（Math.pow(2, 3)）</th>
							<th>1001</th>
							<th>1010</th>
							<th>1011</th>
							<th>1100</th>
							<th>1101</th>
							<th>1110</th>
							<th>1111</th>
						</tr>
						<tr>
							<td class="is-different">校验码</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
						</tr>
					</table>
					</div>
					校验码的生成规则为，将所有与该校验码位置的 1 所在位置也为 1 的数据进行异或运算，得到的结果为 0 。比如取第一个校验码，位置是 0001，那么就取所有位置为 XXX1 的数据进行异或运算：
					<pre><code class="javascript">
<span class="strong">0001的校验码</span> ^ 0011的数据 ^ 0101的数据 ^ 0111的数据 ^ 1001的数据 ^ 1011的数据 ^ 1101的数据 ^ 1111的数据
					</code></pre>
					得到的值必须为 0 ，因为除了要求的 0001 其他的数据都是已知，所以可以求出校验码的值。
					<div class="tip">
						异或运算符合交换律。进行异或运算其实是看有多少个 1 ，1 与无限个 0 进行异或运算的结果还是 1 ，然后偶数个 1 进行异或得到 0 ，奇数个 1 进行异或得到 1 。所以进行以上异或运算必须要有偶数个 1 才能得到结果 0 。
					</div>
					收到数据 + 校验码后在进行校验，如果进行异或运算结果是 1 ，则说明数据出现了问题，无论是数据从 0 变成了 1 还是 1 变成 0 都会使得异或运算的结果有问题，使用这个方法我们可以知道出错的位置在哪里，实现纠错功能。
				</p>
				<h3>安全</h3>
				<p>
					<h4>攻击</h4>
					<ul>
						<li>主动攻击：中断、修改、伪造数据</li>
						<li>被动攻击：非法获得某些数据，但又不修改这些数据，也就是窃取 / 偷窥</li>
					</ul>
					<h4>防火墙</h4>
					<ol>
						<li>日记与事件记录：记录网络使用情况</li>
						<li>审计监控：记录访问日志</li>
						<li>IP 地址转换：NAT 技术</li>
						<li>数据包过滤</li>
						<li>防止内部信息的外泄</li>
						<li>虚拟专用网络</li>
						<li>强化网络安全策略</li>
					</ol>
				</p>
			</p>
		</section>
		<section>
			<h2>CPU</h2>
			<p>
				<h3>控制方式</h3>
				<p>
					进行 IO 操作（外设）时候，怎么让 CPU 知道 IO 操作是否完成，在 IO 时 CPU 又在做什么？
					<ul>
						<li>程序查询方式：即让 CPU 不停地询问外设是否完成，这个过程 CPU 只做询问，不做其他事情</li>
						<li>程序中断方式：CPU 和外设各自进行工作，当外设完成工作的时，给 CPU 一个中断信号，CPU 就会停下手头的工作（保存现场信息）来处理中断信息，处理完之后再恢复现场信息</li>
						<li>DMA：Direct Memory Access，直接借助硬件来完成 IO 操作，CPU 可以不用专门管理 IO 过程</li>
					</ul>
				</p>
			</p>
		</section>
		<section>
			<h2>模型</h2>
			<p>
				<h3>数据流图 / DFD</h3>
				<p>
					数据流图从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程。<sup>[1]</sup>
					<ul>
						<li>数据流：数据在系统内传播的路径，如姓名、年龄、单位、身份证号、日期、目的地等</li>
						<li>数据源或宿：代表系统之外的实体，如人、动物、系统</li>
						<li>加工：对数据进行处理的单元</li>
						<li>数据存储：表示信息的静态存储</li>
					</ul>
				</p>
				<h3>关系实体图 / E-R图</h3>
				<p>
					想想你的数据库原理怎么学的。
				</p>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p>
				<div>[1] 数据流图 <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4136477?fromtitle=dfd&fromid=65845&fr=aladdin#1">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4136477?fromtitle=dfd&fromid=65845&fr=aladdin#1</a></div>
			</p>
		</section>
	</article>
</body>
</html>