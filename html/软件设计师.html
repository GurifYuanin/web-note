<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>软件设计师</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/agate.css">
	<link rel="stylesheet" href="../css/dark.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">软件设计师</h1>
		</hgroup>
		<section>
			<h2>程序语言</h2>
			<p>
				<h3>文法</h3>
				<p>
					文法是推导规则，比如
					<pre><code class="language">
A → B|C|DEF
					</code></pre>
					那么就表示 A 可以推出 B 或 C 或 DEF ，A 称为开始符号，也称为非终结符（Vn），如果 B 推不出任何东西，则 B 称之为终结符（Vr）。进行推导本身的文法和所有被推导出来的结果称之为产生式。
					<ul>
						<li>算符文法：所有产生式的右边都不包含连续的两个非终结符</li>
						<li>终结符优先级：其实就是看终结符哪个先被推导出来，先被推导出来的优先级大于后出现的</li>
					</ul>
					文法类型：
					<ul>
						<li>左线性文法：左边只有一个符号，右边是非终结符 + 终结符</li>
						<li>右线性文法：左边只有一个符号，右边是终结符 + 非终结符</li>
						<li>3 型文法：左边只有一个符号，右边最多两个符号，如果是两个符号则必须是终结符 + 非终结符</li>
						<li>2 型文法：左边只有一个符号，右边有限个符号</li>
						<li>1 型文法：左边任意个符号，但至少要有一个终结符，右边有限个符号</li>
						<li>0 型文法：任意文法</li>
					</ul>
				</p>
				<h3>相关概念</h3>
				<p>
					假设有<span class="different"> A → BF </span>和<span class="different"> B → CDE </span>和<span class="different"> F → G </span>和<span class="different"> C → H</span>。
					构建树得到：
					<figure>
						<img src="../images/software_engineer_tree.jpg">
					</figure>
					<ul>
						<li>短语：构建一棵树后取任意一个子树，推导到最终得到的结果。比如上图就是 HDEF、HDE、H 和 G</li>
						<li>直接短语：基于短语的基础上，如果推导一次就结束了，比如 F → G 然后 G 无法再进行推导，则称为直接短语。比如上图的 H 和 G</li>
						<li>句柄：基于直接短语的基础上，如果推导处于最左边，比如 C → H，则成为句柄。比如 C</li>
						<li>最左推导：每次都优先从最左边进行推导，比如 AXXXC 里虽然 C 可以推导为 D，但结果只能是 BXXXC，C 被不可推导的 X 挡住了</li>
						<li>最右推导：每次都优先从最右边进行推导，在形式语言中，最右推导常被称为规范推导</li>
						<li>推导：可以在任意位置进行推导</li>
					</ul>
				</p>
				<h3>编译程序</h3>
				<p>
					<ol>
						<li>词法分析：将字符序列转化为 token 的过程。用户输入的只是一系列字符，词法分析则将这些字符进行切割</li>
						<li>语法分析：将 token 序列组成语法短语</li>
						<ul>
							<li>自上向下：给定文法G和源程序串r，按照正常顺序进行<span class="different">推导</span>得到r。有<span class="definition"> LL(1) </span>方法</li>
							<li>自下向上：从给定的输入串r开始，不断寻找子串与文法G中某个产生式P的候选式进行匹配，并用P的左部代替(归约)之，逐步<span class="different">归约</span>到开始符号S。有<span class="definition"> LR(1)、SLR(1)、LALR(1) </span>方法</li>
						</ul>
						<li>语义分析：对程序的语义进行解释</li>
						<li>中间代码生成</li>
						<li>代码优化</li>
						<li>目标代码生成</li>
					</ol>
				</p>
			</p>
		</section>
		<section>
			<h2>网络</h2>
			<p>
				<h3>ISO 7 层模型</h3>
				<p>
					<ol>
						<li>物理层：物理上存在的数据传输线路线，以 bit 传输：网线、集线器、中继器、HUB</li>
						<li>数据链路层：寻找物理地址，重发，流控制，以数据帧传输：网卡、二层交换机、网桥</li>
						<li>网络层：路由寻址，分组转发，以数据包传输：路由器、防火墙、多层交换机</li>
						<li>传输层：进程间的连接建立，控制数据包的发送，以数据段传输：进程、端口</li>
						<li>会话层：会话管理，访问校验</li>
						<li>表示层：加密解密，编码解码，压缩解压</li>
						<li>应用层：提供网络服务接口</li>
					</ol>
				</p>
				<h3>TCP/IP协议组</h3>
				<p>
					<ol>
						<li>物理层</li>
						<li>数据链路层</li>
						<li>网络层：有 IP、ICMP、ARP 与 RARP 等协议</li>
						<li>传输层：有 TCP、UDP 等协议</li>
						<li>应用层：有 HTTP、FTP、Telnet 等协议</li>
					</ol>
					<table>
						<tr>
							<th>协议</th>
							<th>端口</th>
						</tr>
						<tr>
							<td>HTTP</td>
							<td>80</td>
						</tr>
						<tr>
							<td>HTTPS</td>
							<td>43</td>
						</tr>
						<tr>
							<td>FTP</td>
							<td>21</td>
						</tr>
						<tr>
							<td>TCP</td>
							<td>22</td>
						</tr>
						<tr>
							<td>Telnet</td>
							<td>23</td>
						</tr>
						<tr>
							<td>SMTP</td>
							<td>25</td>
						</tr>
						<tr>
							<td>POP3</td>
							<td>110</td>
						</tr>
					</table>
				</p>
				<h3>数据校验(数据链路层)</h3>
				<p>
					<h4>奇偶校验</h4>
					奇偶校验就是在发送的数据后追加一位（bit）数据，若前面的数据 1 的个数为奇数则追加 1（或相反），若前面的数据 1 的个数为偶数则追加 0（或相反）。收到数据后判断最后的这一位是否符合奇偶校验。
					<h4>海明码</h4>
					海明码是在数据里面插入校验数据，插入的位置是 Math.pow(2, k) ，k 是非负整数，比如要传输数据 + 校验码长度为 16 ，也就是数据为 0000 - 1111 。
					<div><table>
						<tr>
							<th>0000</th>
							<th class="is-different">0001（Math.pow(2, 0)）</th>
							<th class="is-different">0010（Math.pow(2, 1)）</th>
							<th>0011</th>
							<th class="is-different">0100（Math.pow(2, 2)）</th>
							<th>0101</th>
							<th>0110</th>
							<th>0111</th>
							<th class="is-different">1000（Math.pow(2, 3)）</th>
							<th>1001</th>
							<th>1010</th>
							<th>1011</th>
							<th>1100</th>
							<th>1101</th>
							<th>1110</th>
							<th>1111</th>
						</tr>
						<tr>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
						</tr>
					</table></div>
					校验码的生成规则为，将所有与该校验码为 1 的那一位所在位置也为 1 的数据进行异或运算，得到的结果为 0 。比如取第一个校验码，位置是 0001，那么就取所有位置为 XXX1 的数据进行异或运算：
					<pre><code class="javascript">
000<span class="strong">1</span>的校验码 ^ 001<span class="strong">1</span>的数据 ^ 010<span class="strong">1</span>的数据 ^ 011<span class="strong">1</span>的数据 ^ 100<span class="strong">1</span>的数据 ^ 101<span class="strong">1</span>的数据 ^ 110<span class="strong">1</span>的数据 ^ 111<span class="strong">1</span>的数据
					</code></pre>
					全部异或运算得到的值必须为 0 ，数据都是已知的，所以可以求出校验码的值。
					<div class="tip">
						异或运算符合交换律。进行异或运算其实是看有多少个 1 ，1 与无限个 0 进行异或运算的结果还是 1 ，然后偶数个 1 进行异或得到 0 ，奇数个 1 进行异或得到 1 。所以进行以上异或运算必须要有偶数个 1 才能得到结果 0 。
					</div>
					收到数据 + 校验码后在进行校验，如果进行异或运算结果是 1 ，则说明数据出现了问题，无论是数据从 0 变成了 1 还是 1 变成 0 都会使得异或运算的结果出错，使用这个方法我们可以知道出错的位置在哪里，实现纠错功能。
					<h4>海明码纠原理</h4>
					一旦数据的一个位出错，将会有多个校验码验算的时候结果不为 0 。相当于一道数学题：<span class="different">如何使用 k 只老鼠检查 Math.pow(2, k) 瓶药剂中哪一瓶（也只有一瓶是）是有毒的？</span>数学模型规定毒药吃下去在一定时间后（比如一周）才会死亡，而只给你一定时间来测试（比如一周）。解决方法是将老鼠按位进行试验。
					<figure>
						<img src="../images/software_engineer_mice_1.jpg">
					</figure>
					将老鼠安排下去，谁的那一列是 1 就得喝一口对应号码的药剂，比如第 k 号老鼠就得喝 1、3、5、7 ...... Math.pow(2, k)号瓶子：
					<figure>
						<img src="../images/software_engineer_mice_2.jpg">
					</figure>
					一周后看死了哪些老鼠，将药剂号码转化成二进制，谁死了说明毒药的二进制数字对应的那一位为 1 ，比如第 k - 1、k 号老鼠死了，其他老鼠没有死，那么 00 ...... 011 号瓶子是毒药，也就是 3 号瓶子是毒药。
					<figure>
						<img src="../images/software_engineer_mice_3.jpg">
					</figure>
					<h4>CRC校验</h4>
					CRC 冗余校验是将 k 位的校验码添加到数据后，如下：
					<div class="show">
						<div style="display: inline-block; width: 50px; height: 50px; border: solid 1px white; margin: 0; padding: 0;">数据</div><div style="display: inline-block; width: 50px; height: 50px; border: solid 1px white; margin: 0; padding: 0;">校验码</div>
					</div>
					收发双方事先规定一个生成多项式 C(X)，比如 C(X) = X<sup>4</sup> + X<sup>2</sup> + X + 1，然后指数次与位进行对应，换成二进制数 10111 。此时如果发送方要发一串数据，比如 1101011，那么通过数据 / 生成多项式得到商和余数，余数就是校验码。
					<figure>
						<img src="../images/software_engineer_crc.jpg">
					</figure>
					然后因为 C(X) 的最高位是 4 次方，所以将数据左移 4 位，即将 1101011 变成 1101011<span class="different">0000</span>，再用这个左移后的数字与校验码 1111 相加，得到最终要发送过去的数据 11010111111。
					<figure>
						<img src="../images/software_engineer_crc_check.jpg">
					</figure>
					接收方收到数据后，根据规定已经知道 C(X) = X<sup>4</sup> + X<sup>2</sup> + X + 1，所以直到最后的 4 位是校验码，此时只需要去掉后 4 位然后也进行一次除运算，如果得到的商和后 4 位一样，则说明没有出错，反之则说明数据传输出错。
				</p>
				<h3>安全</h3>
				<p>
					<h4>攻击</h4>
					<ul>
						<li>主动攻击：中断、修改、伪造数据</li>
						<li>被动攻击：非法获得某些数据，但又不修改这些数据，也就是窃取 / 偷窥</li>
					</ul>
					<h4>防火墙</h4>
					<ol>
						<li>日记与事件记录：记录网络使用情况</li>
						<li>审计监控：记录访问日志</li>
						<li>IP 地址转换：NAT 技术</li>
						<li>数据包过滤</li>
						<li>防止内部信息的外泄</li>
						<li>虚拟专用网络</li>
						<li>强化网络安全策略</li>
					</ol>
				</p>

			</p>
		</section>
		<section>
			<h2>CPU</h2>
			<p>
				<h3>控制方式</h3>
				<p>
					进行 IO 操作（外设）时候，怎么让 CPU 知道 IO 操作是否完成，在 IO 时 CPU 又在做什么？
					<ul>
						<li>程序查询方式：即让 CPU 不停地询问外设是否完成，这个过程 CPU 只做询问，不做其他事情</li>
						<li>程序中断方式：CPU 和外设各自进行工作，当外设完成工作的时，给 CPU 一个中断信号，CPU 就会停下手头的工作（保存现场信息）来处理中断信息，处理完之后再恢复现场信息</li>
						<li>DMA：Direct Memory Access，直接借助硬件来完成 IO 操作，CPU 可以不用专门管理 IO 过程</li>
					</ul>
				</p>
			</p>
		</section>
		<section>
			<h2>操作系统</h2>
			<p>
				<h3>PCB</h3>
				<p>
					PCB：进程控制块，一种专门描述进程的数据结构，有这个进程控制块，系统才感知到进程。
					<figure>
						<img src="../images/software_engineer_pcb.jpg">
						<figcaption>https://baike.baidu.com/item/进程控制块/7205297?fr=aladdin</figcaption>
					</figure>
					PCB 放在系统的内存上，由于系统上运行着多个进程，系统需要知道哪些进程正在执行，哪些进程阻塞中，所以就需要根据 PCB 来调度进程，有三种存放方式：
					<ul>
						<li>线性表方式：不管进程的状态，直接将所有 PCB 顺序放置</li>
						<li>索引表方式：维护一个就绪索引表和一个阻塞索引表，索引是 PCB 块的首地址</li>
						<figure>
							<img src="../images/software_engineer_pcb_index.jpg">
						</figure>
						<li>链接表方式：每个 PCB 块都有一个指针，指向下一个 PCB 块的首地址，然后创建就绪指针、阻塞指针、空闲指针，分别指向一个 PCB 块的首地址。当进程状态发生改变的时候，就将这个进程的 PCB 链接到另一个链表上。</li>
						<figure>
							<img src="../images/software_engineer_pcb_link.jpg">
							<figcaption>https://blog.csdn.net/canyanruxue/article/details/78439934</figcaption>
						</figure>
					</ul>
				</p>
				<h3>磁盘</h3>
				<p>
					<h4>磁盘结构</h4>
					<figure>
						<img src="../images/software_engineer_disk.jpg">
						<figcaption>磁盘结构</figcaption>
					</figure>
					<ul>
						<li>磁盘片：上下面都可以存储数据</li>
						<li>磁道：磁盘片上的同心圆</li>
						<li>扇区：磁道切割成若干个扇区，一个扇区称之为一个盘块（数据块）</li>
					</ul>
					<h4>时间计算</h4>
					磁盘是一直在旋转的，读写的磁头则由主杆操作只能进行前后移动，所以如果要读取磁盘上某个地方的数据，需要：
					<ol>
						<li>主杆控制磁头移动到目标磁道上：设 m 类似于主杆移动速度，是一个常数，n 是磁头距离目标有多少磁道，s 主杆启动时间，这个过程需要总时间 s + m * n</li>
						<li>等待磁盘旋转到磁头的位置：由于磁盘旋转无法停止，所以磁头移动到目标磁道上的时候既有可能是刚好就可以进行读写，也可能刚好错过，因此使用 T / 2 作为计算时间，T 是磁盘旋转一周所需时间</li>
						<li>传输时间：r 为磁盘每秒转多少圈，N 为一条磁道上有多少字节，b 为要读取多少字节，因此需要时间 b / (r * N)</li>
					</ol>
					<h4>磁盘调度</h4>
					当有多个读写请求的时候，该先响应哪个请求？
					<ul>
						<li>先来先服务（FCFS）：顾名思义。但可能恰好几个请求的读写位置相差甚远，导致磁头跑来跑去</li>
						<li>最短寻道优先（SSTF）：根据现在磁头所在的位置，优先选择一条最近的。但可能让磁头一直待在某个地方，因为不断有近的请求进来，导致虽然先来但是请求位置比较远而一直得不到响应</li>
						<li>扫描算法（SCAN）：电梯算法，每次都只向一个方向移动，直到这个方向上没有请求，再调换方向</li>
						<li>循环扫描算法：从最外层有请求的磁道往最内层磁道扫描，扫完后回到最外侧有请求的磁道，重复以上</li>
						<li>NStepSCAN：先将众多请求分成若干个子队列，然后依次对每个子队列使用扫描算法</li>
						<li>FSCAN 调度算法：将众多请求分成若两个子队列，然后依次对子队列使用扫描算法</li>
					</ul>
				</p>
				<h3>磁盘分配</h3>
				<p>
					一个磁盘被分为多个同心圆的磁道，一个磁盘又被分为多个扇区 / 数据块，如果我们有一些数据，需要 k 个数据块才能存储，那么该如何分配与组织数据块？
					<ul>
						<li>连续分配方式：直接分配相邻数据块，只需要知道第一个盘块号是多少以及块数，就可以直接连续读取，但需要预先知道是否有足够多的连续数据块</li>
						<li>不连续分配：隐式链接、显式链接、索引</li>
						<ul>
							<li>隐式链接：每一个盘块保存一个指针，指向下一个盘块的盘块号，读写的时候只能从头开始</li>
							<li>显式链接：维护一张文件分配表（FAT），一个 PCB 只需要保存这个表的索引，就可以通过表来寻找所有数据块</li>
							<figure>
								<img src="../images/software_engineer_fat_table.jpg">
							</figure>
							<li>索引分配：文件分配表（FAT）提供了所有盘块的索引，然而有时候并不需要知道所有的索引。索引分配就是为每个文件分配一张索引表，每次读取某个文件只需要调出对应的表就行</li>
							<figure>
								<img src="../images/software_engineer_file_index.jpg">
							</figure>
							<ul>
								<li>一级索引分配：如上图</li>
								<li>多级索引分配：索引表保存的盘号还是一个索引表，多次索引后才是数据真正的地址</li>
							</ul>
							<li>混合索引：既可能有直接地址，也可能有一级、多级索引</li>
						</ul>
					</ul>
					<h4>两级索引计算</h4>
					假设一个盘块大小为 p ，保存一个盘块号需要占用 h 大小，那么一个盘块可以保存 p / h 个盘块号，采用两级索引，因此一个盘块可以索引到 (p / h) * (p / h) 个盘块，前面已经知道一个盘块大小为 p ，所以两级索引下一个盘块可以索引出 (p / h) * (p / h) * p 长度的文件。
				</p>
				<h3>内存分配</h3>
				<p>
					用户执行程序，首先就需要将程序装入内容，但一个程序的大小不确定，该怎么分，分多少？于是就有了不同的内存分配策略：
					<ul>
						<li>连续分配策略：即直接给程序分配一个完整的可以运行程序的内存空间</li>
						<ul>
							<li>单一连续分配：简单地将内存划分为用户区和系统区，用户直接使用整个用户区，所以只适合单用户单任务（不然就会开抢然后谁抢到就是谁的）</li>
							<li>固定分区分配：将内存划分为固定的大小的分区（大小可能不等也可能相等），然后进程像取蛋糕一样拿走分区，执行完程序之后让出分区</li>
							<li>动态分区分配：看情况来划分分区大小，然后再看情况决定给进程分配哪个分区，这样可以划分出刚刚好大小的分区给程序。于是有一些分配算法：</li>
							<ul>
								<li>首次适应算法：从头到尾，找出第一个可以容纳程序大小的分区</li>
								<li>循环首次适应算法：从上次的地方出发，找到第一个可以容纳程序大小的分区</li>
								<li>最佳适应：找到能容纳且差值最小的分区</li>
								<li>最坏适应：找到能容纳且差值最大的分区</li>
								<li>快速适应算法：放弃 "划分刚刚好和程序大小" 的原则，分区大小划分为 Math.pow(2, k) 数量级，然后由于已经知道分区大小，直接拿合适的分区分配给程序，省去了查找的过程</li>
							</ul>
						</ul>
						<li>非连续分配：程序代码分散装入内存不同地方</li>
						<ul>
							<li>分页存储</li>
							<li>分段存储</li>
							<li>分页 + 分段</li>
						</ul>
					</ul>
					<h4>分页</h4>
					分页方式将程序的代码进行打散然后存入内存的不同地方，然后有两个概念：
					<ul>
						<li>分页：将程序分为若干个页面，每个页面有一个编号，即 0 1 2 3 4 ... 这样</li>
						<li>分块：将内存分为若干个物理块，每一个物理块有一个编号，即 0 1 2 3 4 ... 这样</li>
					</ul>
					分完之后，每一个程序都会有一个页表，页表实际上是实现页面编号和物理块编号的映射：
					<figure>
						<img src="../images/software_engineer_page_table.jpg">
					</figure>
					这样想要知道程序每一页在内存的地址在哪里，就可以查这个页表，获得物理块号，但如果是代码执行，还需要知道一个东西，代码执行到哪一行了？通过页表只能查到物理块编号，通过计算可以得到这个物理块的首地址：
					<pre><code class="os">
页号 -> 通过页表查询 -> 得到物理块号 再乘以 物理块大小 -> 对应物理块首地址
					</code></pre>
					所以我们还得知道偏移地址，也就是完整的查询分页的地址应该有以下结构：
					<div class="show">
						<div style="float: left; border: solid 1px gray; padding: 5px;">页号</div>
						<div style="float: left; border: solid 1px gray; padding: 5px;">偏移量</div>
					</div>
					完整的地址查询：
					<pre><code class="os">
页号 -> 通过页表查询 -> 得到物理块号 再乘以 物理块大小 -> 对应物理块首地址 加上 偏移地址 -> 代码执行地址
					</code></pre>
				</p>
			</p>
		</section>
		<section>
			<h2>软件工程</h2>
			<p>
				<h3>软件配置管理</h3>
				<p>
					Software Configuration Management，对每个项目的变更进行管控（版本控制），并维护不同项目之间的版本关联，以使软件在开发过程中任一时间的内容都可以被追溯<sup>[5]</sup>，主要进行以下内容：
					<ul>
						<li>配置项</li>
						<li>配置状态报告</li>
						<li>工作空间管理</li>
						<li>版本控制 / 管理</li>
						<li>变更控制 / 管理</li>
						<li>过程支持</li>
					</ul>
				</p>
				<h3>开发方法</h3>
				<p>
					<ul>
						<li>敏捷开发：程序员团队与业务专家之间的紧密协作、面对面的沟通、频繁交付新的软件版本、紧凑而自我组织型的团队</li>
						<ul>
							<li>极限编程：将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程</li>
						</ul>
						<li>迭代开发：整个开发工作被组织为一系列的短小的、固定长度（如3周）的小项目，被称为一系列的迭代。每一次迭代都包括了定义、需求分析、设计、实现与测试。</li>
						<li>瀑布式开发：严格遵循预先计划的需求、分析、设计、编码、测试的步骤顺序进行。</li>
					</ul>
				</p>
				<h3>耦合 & 内聚</h3>
				<p>
					耦合描述模块与模块之间的联系程度，耦合度越低越好，耦合程度从高到低：
					<ul>
						<li>内容耦合：一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部</li>
						<li>公共耦合：通过一个公共数据环境相互作用的那些模块间的耦合</li>
						<li>外部耦合：两个模块共用一个外加的数据格式、通信协议或是设备界面</li>
						<li>控制耦合：一个模块传递控制变量给另一个模块</li>
						<li>特征 / 标记 / 数据结构耦合：几个模块共享一个复杂的数据结构</li>
						<li>数据耦合：一个传入基本类型的值给另一个模块</li>
						<li>消息耦合：状态的去中心化，组件间利用传入值或消息传递来通信</li>
						<li>无耦合</li>
					</ul>
					内聚描述模块内功能独立程度，内聚越高越好，内聚程度从低到高：
					<ul>
						<li>偶然内聚：模块中各机能之间唯一的关系是其位在同一个模块中</li>
						<li>逻辑内聚：逻辑上分为同一类就放同意模块中</li>
						<li>时间性内聚：将相近时间点运行的程序，放在同一个模块中（是时间相近，不是时间顺序）</li>
						<li>过程 / 程序内聚：依一组会依照固定顺序运行的程序放在同一个模块中</li>
						<pre><code class="node">
var fs = require('fs');
function readFileAsString(path) {
	fs.stat(path, function(err, stats) {
		if (err) { console.error(err); }
		else if (stats.isFile()) {
			// 先判断是不是文件
			fs.readFile(path, function(err, data) {
				// 再读取文件
				if (err) { console.error(err); }
				else { console.log(data.toString()); }
			});
		} else { console.error(path + '不是文件'); }
	});
}
						</code></pre>
						<li>联系 / 信息 / 通信内聚：处理相同的数据或者指各处理使用相同的输入数据或者产生相同的输出数据而在同一个模块中</li>
						<pre><code class="javascript">
function modify1(obj) { /* ... */ }
function modify2(obj) { /* ... */ }
function modify3(obj) { /* ... */ }

function modifyObject(obj) {
	modify1(obj);
	modify2(obj);
	modify3(obj);
}
						</code></pre>
						<li>依序 / 顺序内聚：一模块的输出数据是另一个模块的输入，类似工厂的生产线</li>
						<pre><code class="javascript">
function aLotOfCompute(num) {
	var pow = Math.pow(num, 2);
	var length = Math.PI * pow;
	var log = Math.log(length);
	return log;
}
						</code></pre>
						<li>功能内聚：各机能是因为它们都对模块中单一明确定义的任务有贡献</li>
					</ul>
				</p>
				<h3>维护</h3>
				<p>
					<ul>
						<li>更正 / 改正性维护：纠正软件本身的<span class="different"> 错误 </span>而进行的维护</li>
						<li>适应性维护：不是系统错误，但为了适应<span class="different"> 环境 </span>而进行重构，优化等</li>
						<li>改善 / 完善性维护：为系统拓展<span class="different"> 新功能 </span></li>
						<li>预防性维护：考虑到<span class="different"> 未来 </span>而主动进行维护</li>
					</ul>
				</p>
				<h3>数据流图 / DFD</h3>
				<p>
					数据流图从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程。<sup>[1]</sup>
					<ul>
						<li>数据流：数据在系统内传播的路径，如姓名、年龄、单位、身份证号、日期、目的地等</li>
						<li>数据源或宿：代表系统之外的实体，如人、动物、系统</li>
						<li>加工：对数据进行处理的单元</li>
						<li>数据存储：表示信息的静态存储</li>
					</ul>
				</p>
				<h3>关系实体图 / E-R图</h3>
				<p>
					想想你的数据库原理怎么学的。
				</p>
				<h3>UML</h3>
				<p>
					UML，Unify Modify Language 统一方法既统一建模语言。
					<ul>
						<li>用例驱动</li>
						<li>体系结构为中心</li>
						<li>迭代开发或增量开发</li>
					</ul>
				</p>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p>
				<div>[1] 数据流图 <a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4136477?fromtitle=dfd&fromid=65845&fr=aladdin#1">https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE/4136477?fromtitle=dfd&fromid=65845&fr=aladdin#1</a></div>
				<div>[2] 进程控制块 <a href="https://baike.baidu.com/item/进程控制块/7205297?fr=aladdin">https://baike.baidu.com/item/进程控制块/7205297?fr=aladdin</a></div>
				<div>[3] 进程控制块及其作用、组织方式 <a href="https://blog.csdn.net/canyanruxue/article/details/78439934">https://blog.csdn.net/canyanruxue/article/details/78439934</a></div>
				<div>[4] 汤小丹 计算机操作系统(第三版)</div>
				<div>[5] 软件配置管理 <a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/3765602?fr=aladdin">https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/3765602?fr=aladdin</a></div>
			</p>
		</section>
	</article>
</body>
</html>