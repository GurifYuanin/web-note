<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>软件设计师</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/agate.css">
	<link rel="stylesheet" href="../css/dark.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">软件设计师</h1>
		</hgroup>
		<section>
			<h2>程序语言</h2>
			<p>
				<h3>文法</h3>
				<p>
					文法是推导规则，比如
					<pre><code class="language">
A → B|C|DEF
					</code></pre>
					那么就表示 A 可以推出 B 或 C 或 DEF ，A 称为开始符号，也称为非终结符（Vn），如果 B 推不出任何东西，则 B 称之为终结符（Vr）。进行推导本身的文法和所有被推导出来的结果称之为产生式。
					<ul>
						<li>算符文法：所有产生式的右边都不包含连续的两个非终结符</li>
						<li>终结符优先级：其实就是看终结符哪个先被推导出来，先被推导出来的优先级大于后出现的</li>
					</ul>
					文法类型：
					<ul>
						<li>左线性文法：左边只有一个符号，右边是非终结符 + 终结符</li>
						<li>右线性文法：左边只有一个符号，右边是终结符 + 非终结符</li>
						<li>3 型文法：左边只有一个符号，右边最多两个符号，如果是两个符号则必须是终结符 + 非终结符</li>
						<li>2 型文法：左边只有一个符号，右边有限个符号</li>
						<li>1 型文法：左边任意个符号，但至少要有一个终结符，右边有限个符号</li>
						<li>0 型文法：任意文法</li>
					</ul>
				</p>
				<h3>相关概念</h3>
				<p>
					假设有<span class="different"> A → BF </span>和<span class="different"> B → CDE </span>和<span class="different"> F → G </span>和<span class="different"> C → H</span>。
					构建树得到：
					<figure>
						<img src="../images/software_engineer_tree.jpg">
					</figure>
					<ul>
						<li>短语：构建一棵树后取任意一个子树，推导到最终得到的结果。比如上图就是 HDEF、HDE、H 和 G</li>
						<li>直接短语：基于短语的基础上，如果推导一次就结束了，比如 F → G 然后 G 无法再进行推导，则称为直接短语。比如上图的 H 和 G</li>
						<li>句柄：基于直接短语的基础上，如果推导处于最左边，比如 C → H，则成为句柄。比如 C</li>
						<li>最左推导：每次都优先从最左边进行推导，比如 AXXXC 里虽然 C 可以推导为 D，但结果只能是 BXXXC，C 被不可推导的 X 挡住了</li>
						<li>最右推导：每次都优先从最右边进行推导，在形式语言中，最右推导常被称为规范推导</li>
						<li>推导：可以在任意位置进行推导</li>
					</ul>
				</p>
				<h3>编译程序</h3>
				<p>
					<ol>
						<li>词法分析：将字符序列转化为 token 的过程。用户输入的只是一系列字符，词法分析则将这些字符进行切割</li>
						<li>语法分析：将 token 序列组成语法短语</li>
						<ul>
							<li>自上向下：给定文法G和源程序串r，按照正常顺序进行<span class="different">推导</span>得到r。有<span class="definition"> LL(1) </span>方法</li>
							<li>自下向上：从给定的输入串r开始，不断寻找子串与文法G中某个产生式P的候选式进行匹配，并用P的左部代替(归约)之，逐步<span class="different">归约</span>到开始符号S。有<span class="definition"> LR(1)、SLR(1)、LALR(1) </span>方法</li>
						</ul>
						<li>语义分析：对程序的语义进行解释</li>
						<li>中间代码生成</li>
						<li>代码优化</li>
						<li>目标代码生成</li>
					</ol>
				</p>
			</p>
		</section>
		<section>
			<h2>网络</h2>
			<p>
				<h3>ISO 7 层模型</h3>
				<p>
					<ol>
						<li>物理层：物理上存在的数据传输线路，以 bit 传输</li>
						<li>数据链路层：以数据帧传输</li>
						<li>网络层</li>
						<li>传输层</li>
						<li>会话层</li>
						<li>表示层</li>
						<li>应用层</li>
					</ol>
				</p>
				<h3>TCP/IP协议组</h3>
				<p>
					<ol>
						<li>物理层</li>
						<li>数据链路层</li>
						<li>网络层：有 IP、ICMP、ARP 与 RARP 等协议</li>
						<li>传输层：有 TCP、UDP 等协议</li>
						<li>应用层：有 HTTP、FTP、Telnet 等协议</li>
					</ol>
				</p>
				<h3>数据校验</h3>
				<p>
					<h4>奇偶校验</h4>
					奇偶校验就是在发送的数据后追加一位（bit）数据，若前面的数据 1 的个数为奇数则追加 1（或相反），若前面的数据 1 的个数为偶数则追加 0（或相反）。收到数据后判断最后的这一位是否符合奇偶校验。
					<h4>海明码</h4>
					海明码是在数据里面插入校验数据，插入的位置是 Math.pow(2, k) ，k 是非负整数，比如要传输数据加校验码长度为 16：
					<div>
					<table>
						<tr>
							<th class="is-different">0001（Math.pow(2, 0)）</th>
							<th class="is-different">0010（Math.pow(2, 1)）</th>
							<th>0011</th>
							<th class="is-different">0100（Math.pow(2, 2)）</th>
							<th>0101</th>
							<th>0110</th>
							<th>0111</th>
							<th class="is-different">1000（Math.pow(2, 3)）</th>
							<th>1001</th>
							<th>1010</th>
							<th>1011</th>
							<th>1100</th>
							<th>1101</th>
							<th>1110</th>
							<th>1111</th>
						</tr>
						<tr>
							<td class="is-different">校验码</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td class="is-different">校验码</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
							<td>数据</td>
						</tr>
					</table>
					</div>
					校验码的生成规则为，将所有与该校验码位置的 1 所在位置也为 1 的数据进行异或运算，得到的结果为 0 。比如取第一个校验码，位置是 0001，那么就取所有位置为 XXX1 的数据进行异或运算：
					<pre><code class="javascript">
<span class="strong">0001的校验码</span> ^ 0011的数据 ^ 0101的数据 ^ 0111的数据 ^ 1001的数据 ^ 1011的数据 ^ 1101的数据 ^ 1111的数据
					</code></pre>
					得到的值必须为 0 ，因为除了要求的 0001 其他的数据都是已知，所以可以求出校验码的值。
					<div class="tip">
						异或运算符合交换律。进行异或运算其实是看有多少个 1 ，1 与无限个 0 进行异或运算的结果还是 1 ，然后偶数个 1 进行异或得到 0 ，奇数个 1 进行异或得到 1 。所以进行以上异或运算必须要有偶数个 1 才能得到结果 0 。
					</div>
					收到数据 + 校验码后在进行校验，如果进行异或运算结果是 1 ，则说明数据出现了问题，无论是数据从 0 变成了 1 还是 1 变成 0 都会使得异或运算的结果有问题，使用这个方法我们可以知道出错的位置在哪里，实现纠错功能。
				</p>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p></p>
		</section>
	</article>
</body>
</html>