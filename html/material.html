<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>material</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/agate.css">
	<link rel="stylesheet" href="../css/dark.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
	<script src="../js/three.min.js"></script>
	<script src="../js/three-init.js"></script>
	<script src="../js/OrbitControls.js"></script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/catalog.png" alt="加载失败">
			目录
		</section>
	</aside>
	<div id="showCatalog">
		<img src="../images/arrow.png">
	</div>
	<article id="container">
		<hgroup>
			<h1 id="title">material</h1>
		</hgroup>
		<section>
			<h2>定义</h2>
			<p>
				material，材质，在计算机图形学中用于描述物体的外貌。
			</p>
		</section>
		<section>
			<h2>Material 抽象类</h2>
			<p>
				所有属于材质的类都会继承 Material 类，拥有该类的所有成员和方法。
				<h3>transparent & ooacity</h3>
				<p>
					<ul>
						<li>transparent 是一个布尔值，默认为 false，表示材质不是透明的，即不透明度为 1 。当设置为 true 时，材质才可能是透明的，opacity 属性才会生效。</li>
						<li>opacity 表示材质的透明度，默认为 1 ，表示不透明，设置为 0 时表示完全透明。</li>
					</ul>
				</p>
				<h3>vertexColors</h3>
				<p>
					vertexColors 控制被着色物体的各个面的颜色，可以赋为三个值：
					<ul>
						<li>THREE.NoColors：默认，表示直接使用材质的颜色为整个物体的所有面着一个颜色 material.color（纯色）</li>
						<li>THREE.FaceColors：面（Face3）有一个属性 color，为每个面着该属性的颜色</li>
						<li>THREE.VertexColors：面（Face3）有一个属性 vertexColors，表示面的三个顶点的颜色，为每个面按照该属性的三个颜色值进行渐变着色</li>
					</ul>
					<div class="show">
						<div id="vertex-colors-container"></div>
						material.vertexColors：
						<select id="vertex-colors-select">
							<option value="0">THREE.NoColors</option>
							<option value="1">THREE.FaceColors</option>
							<option value="2">THREE.VertexColors</option>
						</select>
						<div id="material-color">
							<input id="material-color-checkbox" type="checkbox" checked>
							material.color：
						</div>
						<div id="face-colors">
							<input id="face-colors-checkbox" type="checkbox" checked>
							geometry.faces.color：
						</div>
						<div id="vertex-colors">
							<input id="vertex-colors-checkbox" type="checkbox" checked>
							geometry.faces.vertexColors：
						</div>
						<div style="opacity: .2;" id="colors">geometry.colors：</div>
						<style>
							.vertex-color {
								display: inline-block;
								width: 50px;
								height: 50px;
							}
						</style>
						<script>
							(function() {
								function getRandomColor() { return Math.round(Math.random() * 0xffffff); }
								function appendColorBlock(bgc, ctx) {
									var e = document.createElement('div');
									e.setAttribute('class', 'vertex-color');
									e.setAttribute('title', bgc.toUpperCase());
									e.style.backgroundColor = '#' + bgc;
									ctx.appendChild(e);
								}
								var renderer = initRenderer(document.getElementById('vertex-colors-container'));
								renderer.setSize(400, 400);
								var camera = initCamera();
								var scene = initScene();

								// color
								var materialColor = new THREE.Color(getRandomColor());
								var materialColorsFlag = true, faceColorsFlag = true, vertexColorsFlag = true;
								var nextMaterialColor = materialColor.clone();
								var nextFaceColors = [];
								var nextVertexColors = [];
								appendColorBlock(
									materialColor.getHexString(),
									document.getElementById('material-color'));


								var geometry = new THREE.BoxGeometry(1, 1, 1);
								var material = new THREE.MeshBasicMaterial({
									color: nextMaterialColor,
									vertexColors: THREE.NoColors
								});
								var faceColors = document.getElementById('face-colors');
								var colors = document.getElementById('colors');
								var vertexColors = document.getElementById('vertex-colors');
								geometry.faces.forEach(function(el, i) {
									var faceColor = new THREE.Color(getRandomColor());
									el.color = faceColor;
									nextFaceColors.push(faceColor);
									appendColorBlock(faceColor.getHexString(), faceColors);

									var c1 = new THREE.Color(getRandomColor());
									var c2 = new THREE.Color(getRandomColor());
									var c3 = new THREE.Color(getRandomColor());
									nextVertexColors.push([c1, c2, c3]);
									el.vertexColors.push(c1, c2, c3);
									appendColorBlock(c1.getHexString(), vertexColors);
									appendColorBlock(c2.getHexString(), vertexColors);
									appendColorBlock(c3.getHexString(), vertexColors);
									vertexColors.appendChild(document.createTextNode(' '));

									var vertexColor = new THREE.Color(getRandomColor());
									geometry.colors.push(vertexColor);
									appendColorBlock(vertexColor.getHexString(), colors);
								});

								var cube = new THREE.Mesh(geometry, material);
								var orbit = new THREE.OrbitControls(camera, renderer.domElement);
								scene.add(cube);
								var selecter = document.getElementById('vertex-colors-select');
								function rerender() {
									scene.remove(cube);
									material = new THREE.MeshBasicMaterial({
										color: nextMaterialColor,
										vertexColors: Number.parseInt(selecter.value)
									});
									cube = new THREE.Mesh(geometry, material);
									scene.add(cube);
								};
								selecter.oninput = rerender;
								document.getElementById('material-color-checkbox').oninput = function() {
									nextMaterialColor = materialColorsFlag ? null : materialColor.clone();
									materialColorsFlag = !materialColorsFlag;
									rerender();
								};
								document.getElementById('face-colors-checkbox').oninput = function() {
									geometry = new THREE.BoxGeometry(1, 1, 1);
									geometry.faces.forEach(function(el, i) {
										el.color = faceColorsFlag ? undefined : nextFaceColors[i];
										el.vertexColors = vertexColorsFlag ? nextVertexColors[i] : [];
									});
									faceColorsFlag = !faceColorsFlag;
									rerender();
								};
								document.getElementById('vertex-colors-checkbox').oninput = function() {
									geometry = new THREE.BoxGeometry(1, 1, 1);
									geometry.faces.forEach(function(el, i) {
										el.color = faceColorsFlag ? nextFaceColors[i] : undefined;
										el.vertexColors = vertexColorsFlag ? [] : nextVertexColors[i];
									});
									vertexColorsFlag = !vertexColorsFlag;
									rerender();
								};
								(function render(){
									cube.rotateY(.01);
									cube.rotateZ(.01);
									var rate = Math.abs(Math.sin(Date.now() / 2000)) + 0.7;
									cube.scale.set(rate, rate, rate);
									renderer.render(scene, camera);
									requestAnimationFrame(render);
								})();

							})();
						</script>
					</div>
				</p>
				<h3>shadowSide & side</h3>
				<p>
					side 定义物体的哪个面（Face3）会被渲染出来：
					<ul>
						<li>THREE.FrontSide：默认，前面</li>
						<li>THREE.BackSide：后面</li>
						<li>THREE.DoubleSide：前后面</li>
					</ul>
					shadowSide 定义投影的方向，可赋的值与以上相同，默认为 null，即看 side 的脸色行事。
				</p>
				<h3>混合</h3>
				<p>
					<h4>blending</h4>
					blending 设置物体被材质着色后和背景的混合模式，当材质在物体上着色后，物体将以什么模式呈现：
					<ul>
						<li>THREE.NoBlending：不混合</li>
						<li>THREE.NormalBlending：默认，正常混合模式，上层颜色直接覆盖下层颜色</li>
						<li>THREE.AdditiveBlending：加色模式，上层颜色和下层颜色相加，最终效果变亮</li>
						<li>THREE.SubtractiveBlending：减色模式，上层颜色和下层颜色相减，最终效果变暗</li>
						<li>THREE.MultiplyBlending：乘法，上层颜色和下层颜色相乘</li>
						<li>THREE.CustomBlending：自定义模式，可以自己写表达式计算混合后的颜色</li>
					</ul>
					设置为自定义混合模式后，可以自己写混合方式，关于混合的讲解：<sup>[2]</sup>
					<div class="show">
						<div>所谓混合就是在绘制时，不是直接把新的颜色覆盖在原来旧的颜色上，而是将新的颜色与旧的颜色经过一定的运算，获得最终的混合颜色。</div>
						<div>其中新的颜色被称为源颜色，旧的颜色称为目标颜色。传统意义上的混合，是将源颜色乘以源因子，目标颜色乘以目标因子，然后相加。</div>
						<div>源因子和目标因子设置的不同直接导致混合结果的不同。</div>
						<div>下面用数学公式来表达一下这个运算方式。假设源颜色的四个分量（指红色，绿色，蓝色，alpha值）是(Rs, Gs, Bs, As)，目标颜色的四个分量是(Rd, Gd, Bd, Ad)，</div>
						<div>又设源因子为(Sr, Sg, Sb, Sa)，目标因子为(Dr, Dg, Db, Da)。则混合产生的新颜色可以表示为：</div>
						<pre><code class="javascript">
(Rs * Sr + Rd * Dr, // R
 Gs * Sg + Gd * Dg, // G
 Bs * Sb + Bd * Db, // B
 As * Sa + Ad * Da) // Alpha
						</code></pre>
						<div>如果颜色的某一分量超过了1.0，则它会被自动截取为1.0，不应出现越界。</div>
					</div>
					<h4>blendEquation</h4>
					blendEquation 与 blending 不同，blendEquation 设置材质和物体如何进行着色：
					<ul>
						<li>THREE.AddEquation：默认，加色模式，上层颜色和下层颜色相加</li>
						<li>THREE.SubtractEquation：减色模式，上层颜色和下层颜色相减</li>
						<li>THREE.ReverseSubtractEquation：反相</li>
						<li>THREE.MinEquation：最小值，上层颜色和下层颜色取最小值</li>
						<li>THREE.MaxEquation：最大值，上层颜色和下层颜色取最大值</li>
					</ul>
				</p>
				<h3>多边形偏移</h3>
				<p>
					设置模型的线框和实体之间的偏移距离，公式为：<sup>[3]</sup>
					<div class="command">offset = (m * factor) + (r * units)</div>
					<ul>
						<li>m：多边形的深度的斜率</li>
						<li>factor：多边形偏移因子</li>
						<li>r：产生在窗口坐标系的深度值中可分辨的差异的最小值，常量</li>
						<li>units：多边形偏移单位</li>
					</ul>
					offset 大于 0 表示物体远离摄像机，小于 0 表示物体靠近摄像机，threejs 提供修改 factor 和 units 。
					<h4>polygonOffset</h4>
					多边形偏移开关，默认为 false ，即关闭。
					<h4>polygonOffsetFactor</h4>
					多边形偏移因子，默认为 0 。
					<h4>polygonOffsetUnits</h4>
					多边形偏移单位，默认为 0 。
				</p>
			</p>
		</section>
		<section>
			<h2>MeshBasicMaterial</h2>
			<p>
				通过一个简单的方式来为物体着色，他继承了 Material 类，所以拥有 Material 类的所有成员和方法，创建实例时传入以选项对象。 MeshBasicMaterial 不受灯光的影响。
				<pre><code class="javascript">
var options = {
	// 各种参数
};
var material = new THREE.MeshBasicMaterial(options);
				</code></pre>
				<h3>color</h3>
				<p>
					定义材质的颜色，默认为白色（0x000000），你可以设置为 null 从而关闭基础颜色。
				</p>
				<h3>各种贴图</h3>
				<p>
					各种贴图默认都为 null 。
					<ul>
						<li>map：颜色贴图</li>
						<li>alphaMap：alpha 贴图</li>
						<li>aoMap：环境遮挡贴图</li>
						<li>envMap：环境贴图</li>
						<li>specularMap：高光贴图</li>
					</ul>
					threejs 官方提供了材质加载工具 TextureLoader 来加载图像：
					<pre><code class="javascript">
var url = '图片的地址';
var texture = new THREE.TextureLoader().load(url, function() {
	console.log('加载完毕');
}, function() {
	console.log('加载中');
}, function() {
	console.error('加载出错');
});
var material = new THREE.MeshBasicMaterial({map: texture});
					</code></pre>
					该方法是异步的，第一个参数为图片地址，其后三个参数分别为加载完成的回调，加载中的回调和加载出错的回调。
					<div class="show">
						<div id="map-container"></div>
						<script>
							(function() {
								var scene = initScene();
								var camera = initCamera();
								var renderer = initRenderer(document.getElementById('map-container'));
								var material = new THREE.MeshBasicMaterial({
									color: 0xffffff,
									map: new THREE.TextureLoader().load('../images/posz.jpg')
								});
								new THREE.OrbitControls(camera, renderer.domElement);
								var geometry = new THREE.CubeGeometry(1, 1, 1);
								var mesh = initMesh(geometry, material);
								scene.add(mesh);
								(function render(){
									mesh.rotateY(.05);
									renderer.render(scene, camera);
									requestAnimationFrame(render);
								})();
							})();
						</script>
					</div>
					当然也可以不写回调直接通过 requestAnimationFrame 循环渲染。
					<pre><code class="javascript">
(function render() {
	renderer.render(scene, camera);
	requestAnimationFrame(render);
})();
					</code></pre>
				</p>
				<h3>反射与折射</h3>
				<p>
					<ul>
						<li>reflectivity：反射率，默认为 1</li>
						<li>refractionRatio：折射率，默认为 0.98</li>
					</ul>
				</p>
				<h3>线框</h3>
				<p>
					<ul>
						<li>wireframe：是否描绘线框，默认为 false</li>
						<li>wireframeLinewidth：线框宽度（厚度），默认为 1</li>
						<li>wireframeLinecap：端点样式，默认为 round</li>
						<li>wireframeLinejoin：连接点样式，默认为 round</li>
					</ul>
					只有 wireframe 属性是有效的，wireframeLinejoin 和 wireframeLinecap 只是对应于 webgl 2D wireframeLinewidth 受限于渲染器在大多数平台上只能是 1 即使修改为其他值。
				</p>
			</p>
		</section>
		<section>
			<h2>LineBasicMaterial</h2>
			<p>
				用于绘制简答线框的材质。
				<div class="show">
					<div id="line-container"></div>
					<script>
						(function() {
							var renderer = initRenderer(document.getElementById('line-container'))
							var camera = initCamera();
							var scene = initScene();
							var mesh = new THREE.Line(new THREE.CubeGeometry(1, 1, 1), new THREE.LineBasicMaterial({color: 0xffffff}));
							scene.add(mesh);
							new THREE.OrbitControls(camera, renderer.domElement);
							(function render() {
								mesh.rotateY(.01);
								renderer.render(scene, camera);
								requestAnimationFrame(render);
							})();
						})();
					</script>
				</div>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<p>
				<div>[1] Three doc Material <a href="https://threejs.org/docs/index.html#api/en/materials/Material">https://threejs.org/docs/index.html#api/en/materials/Material</a></div>
				<div>[2] three在线中文文档 <a href="http://techbrood.com/threejs/docs/#参考手册/常量(Constants)/自定义混合方程(CustomBlendingEquation)">http://techbrood.com/threejs/docs/#参考手册/常量(Constants)/自定义混合方程(CustomBlendingEquation)</a></div>
				<div>[3] BIT祝威 [OpenGL][SharpGL]用Polygon Offset解决z-fighting和stitching问题 <a href="https://www.cnblogs.com/bitzhuwei/archive/2015/06/12/4571539.html">https://www.cnblogs.com/bitzhuwei/archive/2015/06/12/4571539.html</a></div>
				<div>[4] TextureLoader <a href="https://threejs.org/docs/index.html#api/en/loaders/TextureLoader">https://threejs.org/docs/index.html#api/en/loaders/TextureLoader</a></div>
			</p>
		</section>
	</article>
</body>
</html>