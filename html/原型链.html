<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>原型链</title>
	<link rel="stylesheet" href="../css/normalize.css">
	<link rel="stylesheet" href="../css/styles/default.css">
	<link rel="stylesheet" href="../css/sidebar.css">
	<script src="../js/jquery-3.2.1-compressed.js"></script>
	<script src="../js/highlight.pack.js"></script>
	<script src="../js/sidebar.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
	<aside id="sidebar">
		<section id="catalog">
			<img id="hideCatalog" src="../images/目录.png" alt="加载失败">
			目录
		</section>
	</aside>
	<article id="container">
		<hgroup>
			<h1>原型链</h1>
		</hgroup>
		<section>
			<h2>定义</h2>
			<p>
				如果说作用域链是使用变量或函数时的一种索引顺序，那么原型链就是使用对象的属性时，查找该属性的一种索引顺序。<br>
				在 javascript 中，通过函数通常有两种方法来创建对象（实例）。
				<ul>
					<li>工厂方法</li>
					<li>构造函数 + 原型模式</li>
				</ul>
			</p>
		</section>
		<section>
			<h2>工厂方法</h2>
			<p>
				工厂方法本质是在函数内创建一个对象，最终将该对象返回，是一种对象创建的封装。<br>
				<pre><code class="javascript">
			function createObject () {
				var object = {};
				object.property = value;
				object.function = function () {};
				return object;
			}
			var instance = createObject(); // 调用函数创建对象
				</code></pre>
			</p>
		</section>
		<section>
			<h2>构造函数</h2>
			<p>
				构造函数本质依旧是函数，使用了 new 运算符创建新对象，该对象被赋予构造函数的作用域，然后执行一遍构造函数里的代码，最终自动返回该新对象。
				<pre><code class="javascript">
			function Obj () {
				this.property = value;
				this.function = function() {};
			}
			var instance = new Obj(); // 使用 new 创建新对象
				</code></pre>
				仅使用构造函数的方法存在一个缺点，每个通过 new 创建出的对象是相互独立的，每个对象里面的属性都需要创建一遍，但有时我们需要不同实例拥有同一个属性。例如
				<pre><code class="javascript">
			function Person () {
				this.say = function () {
					alert('hello world');
				};
			}
			var person1 = new Person();
			var person2 = new Person();
			person1.say();
			person2.say();
			alert(person1.say === person2.say); // => false
				</code></pre>
				对于 person1 和 person2 ，两者执行的都是同一件事，即弹出<span class="definition"> hello world </span>，但 person1 和 person2 的 say 方法各被创建了一遍，此时我们更希望它们能共同拥有同一个函数来节省开销。原型模式则可以解决这个问题。
			</p>
		</section>
		<section>
			<h2>原型模式</h2>
			<p>
				需要留意，在 javascript 中：
				<ul>
					<li>每个函数都有一个<span class="definition"> prototype </span>属性（指针）</li>
					<li>每个对象都有一个<span class="definition"> [[prototype]] </span>属性（指针）</li>
				</ul>
				<div class="tip">
					<span class="definition"> prototype </span>指向一个对象（称之为原型对象），该对象初始时只拥有一个属性<span class="definition"> constructor </span>，<span class="definition"> constructor </span>属性指回了<span class="definition"> prototype </span>所在的函数。
				</div>
				<div class="tip">
					<span class="definition"> [[prototype]] </span>指向和创建该对象的函数的<span class="definition"> prototype </span>属性指向的原型对象。该属性无法直接访问（但在 Firefox、Safari 和 chrome 中，可以使用<span class="definition"> __proto__ </span>来进行访问）。
				</div>
				<figure>
					<img style="width: 100%;" src="../images/prototype_chain.jpg" alt="加载失败">
					<figcaption class="description"> 关系图 </figcaption>
				</figure>
				由于每个对象都有<span class="definition"> [[prototype]] </span>属性，该属性指向了一个共同的对象，因此我们可以给自定义的构造函数的<span class="definition"> prototype </span>设置公共属性，之后每次创建新的实例后，创建出来的实例都能拥有相同属性。
				<pre><code class="javascript">
			function Obj () {

			}
			Obj.prototype.say = function() {
				alert('hello world');
			}
			var person1 = new Obj();
			var person2 = new Obj();
			alert(person1.say === person2.say); // => true
				</code></pre>
			</p>
		</section>
		<section>
			<h2>原型链</h2>
			<p>
				从前面的图可以看到，由于每个对象都有一个<span class="definition"> [[prototype]] </span>属性（Object.prototype 除外），因此自定义构造函数的原型对象（自定义构造函数.prototype）本身也有<span class="definition"> [[prototype]] </span>属性，指向了 Object 函数的原型对象，Object.prototype 是一切对象（除 null 和 undefined）的根原型（这也是为什么自定义的对象能使用 toString 等方法）。当实例调用属性的时候，会先从自身对象内部开始查找，如果找不到，就到原型对象里查找，如果还是找不到，就到原型对象的<span class="definition"> [[prototype]] </span>（原型对象的原型对象）所指的下一个原型对象里找，以此类推。这也就是原型链。
				<pre><code class="javascript">
			function Fruit () {
				this.feature = '可以吃';
			}
			function Apple () {
				this.feature = '圆的';
			}
			Apple.prototype = new Fruit(); // 可以直接将一个对象赋值给构造函数的原型对象
			Apple.prototype.constructor = Apple; // 记得把原型对象的构造函数更改回来

			var apple = new Apple();

			alert(apple.feature); // => 圆的
			alert(apple instanceof Apple); // true
			alert(apple instanceof Fruit); // true
			alert(apple instanceof Object); // true
				</code></pre>
				<figure class="fig">
					<img style="max-width: 100%;" src="../images/prototype_chain_2.jpg" alt="加载失败">
				</figure>
			</p>
		</section>
		<section class="refer">
			<h2>参考文献</h2>
			<div>[1] Nicholas C.Zakas Javascript高级程序教程</div>
		</section>
	</article>
</body>
</html>